<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_SlitPair" Id="{e905bacc-19e9-06c3-04ae-f4fd4f34065e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SlitPair
VAR_INPUT
    iBladeNegative: UINT; //Axis ID for negatively positioned blade
    iBladePositive: UINT; //Axis ID for positively positioned blade
    iGapSize: UINT; //Axis ID for the size of gap between slit blades
    iGapCentre: UINT; //Axis ID for the centre position of the gap formed by slit blades
    bEnable: BOOL; //Enable/disable the slit set
    bReset: BOOL; //Reset the slit set
    fEncoderScaling: LREAL := 10000; //default scaling denominator of 10000
    bAutoHome: BOOL := TRUE; // Blades homing is automatically done if they are not homed
    bAnticolisionEnable : BOOL := FALSE;  // Blades anticolision option, only for when blades are moved independiently

END_VAR
VAR_OUTPUT
    bEnabled: BOOL := FALSE; //Enabled status of function
    bError: BOOL; //Error status of function
    bHoming: BOOL := FALSE; //TRUE if function is homing axes
END_VAR
VAR
    eSlitPairState: E_SlitPairStates := E_SlitPairStates.INIT; //statemachine index

//Internal statuses for logic
    bResetting: BOOL := FALSE; //TRUE if axis going through a reset
    bAxesEnabled: BOOL := FALSE; //TRUE if all axes enabled
    bSlitsHomed : BOOL := FALSE; //TRUE if all axes Homed after reboot
    bBladesHomed: BOOL:= FALSE; //TRUE if blade axes are calibrated
    bGapHomed: BOOL:= FALSE; //TRUE if virtual axes are calibrated
    bBladesCoupled: BOOL:= FALSE; //TRUE if both blade axes are coupled
    bBladesUncoupled: BOOL := FALSE; //TRUE if both blade axes are uncoupled
    bAxisErrorsPresent: BOOL := FALSE; //TRUE if error present on any real or virtual axis
    bFunctionInErrorState: BOOL := FALSE; //TRUE if function block is in one of the error related states
    fGapSizePosition: LREAL;
    iGapSizePosition AT %Q*: UDINT := 0;
    fGapCentrePosition: LREAL;
    iGapCentrePosition AT %Q*: UDINT := 0;
    resetCounterTimeout: UINT :=0;
    eSoftLimitsUpdate: E_SlitSoftLimits := E_SlitSoftLimits.START; // Sequence steps for update of soft limits
    fbNoMovingRising: R_TRIG;
    fbInOpRising: R_TRIG;
    bUpdateSoftLimits: BOOL := FALSE;
    bHomingRequested: BOOL := FALSE;
    fbEnableRising: R_TRIG;
    fbStopRising: R_TRIG;
    fbDisableRising: R_TRIG;
    fbDisabledRising: R_TRIG;
    fbHomingRising: R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
(* NOTES
For the virtual axis setup, the encoders need their type changed from "simulation encoder" to "Encoder (Universal)".
In addition the scale factor needs to be changed to a numerator of 1 and denominator of fEncoderScaling which is 10,000 by default)
Care needs to be taken with scaling and setup of both real and virtual axes to ensure velocities are not too fast and axes have time to settle before they submit a "complete move"
Link the virtual encoder inputs to the Gap and Center position calculations iGapSizePosition iGapCentrePosition
Encoder needs to be set as ABSOLUTE
*)

//Configure homing routine of virtual axes
GVL.astAxes[iGapSize].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
GVL.astAxes[iGapCentre].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;

//Run actions for slit set
actErrorHandling(); //Error handling subroutine
actGapLimits(); //Set virtual axis limits to TRUE
actVirtualAxisPositions(); //Virtual axis encoder position subroutine
actRunMethods(); //Update statuses
actEnableAxes(); //Enable the axes
checkSlitsHomed(); // Status of the axes homing
IF bAnticolisionEnable THEN // Blades anticolition enabled
    actInterlocking();
END_IF

CASE eSlitPairState OF
    E_SlitPairStates.INIT:
        bEnabled := FALSE;
        IF bAxesEnabled AND bEnable THEN
            eSlitPairState := E_SlitPairStates.INIT_CLEAR_GEARING;
        END_IF

    E_SlitPairStates.INIT_CLEAR_GEARING:
        actClearSlitGearing();
        eSlitPairState := E_SlitPairStates.INIT_GEAROUT_CHECK;

    E_SlitPairStates.INIT_GEAROUT_CHECK: //Check gearOut completion
        IF bBladesUncoupled THEN
            eSlitPairState := E_SlitPairStates.CHECK_HOME_STATUS;
        END_IF

    E_SlitPairStates.CHECK_HOME_STATUS: //If blades are already homed, skip to virtual homing, if blades not homed and autohome enabled then home blades, otherwise wait for blades to be homed
        IF NOT bSlitsHomed THEN
            //Perform homing
            eSlitPairState := E_SlitPairStates.HOME_BLADES;
        ELSIF bBladesHomed THEN
            eSlitPairState := E_SlitPairStates.HOME_GAP; //Skip to functioning
        ELSIF bAutoHome THEN
            eSlitPairState := E_SlitPairStates.HOME_BLADES; //If autohome enabled, home the blades
        END_IF

    E_SlitPairStates.HOME_BLADES: //Initiate homing of blade axes. Homing routine must be pre-configured by user
        IF (GVL.astAxes[iGapSize].stControl.eCommand = E_MotionFunctions.eHome AND GVL.astAxes[iGapSize].stControl.bExecute) OR
        (GVL.astAxes[iGapCentre].stControl.eCommand = E_MotionFunctions.eHome AND GVL.astAxes[iGapCentre].stControl.bExecute) OR bHomingRequested THEN

            GVL.astAxes[iBladeNegative].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[iBladePositive].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[iBladeNegative].stControl.bExecute := TRUE;
            GVL.astAxes[iBladePositive].stControl.bExecute := TRUE;
            bHoming := TRUE;
            eSlitPairState := E_SlitPairStates.CHECK_BLADE_HOME_COMPLETE;
        END_IF

    E_SlitPairStates.CHECK_BLADE_HOME_COMPLETE: //Wait for completion of blade homing routines
        IF bBladesHomed AND NOT GVL.astAxes[iBladeNegative].stStatus.bBusy AND NOT GVL.astAxes[iBladePositive].stStatus.bBusy THEN
            eSlitPairState := E_SlitPairStates.HOME_GAP;
            bHoming := FALSE;
        ELSIF (GVL.astAxes[iBladeNegative].stStatus.nErrorID > 0) OR (GVL.astAxes[iBladePositive].stStatus.nErrorID >0) THEN
            eSlitPairState := E_SlitPairStates.ERROR;
        END_IF

    E_SlitPairStates.HOME_GAP: //"Home" the virtual axes
        GVL.astAxes[iGapSize].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
        GVL.astAxes[iGapCentre].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
        GVL.astAxes[iGapSize].stConfig.fHomePosition := fGapSizePosition;
        GVL.astAxes[iGapCentre].stConfig.fHomePosition := fGapCentrePosition;
        GVL.astAxes[iGapSize].stControl.eCommand := E_MotionFunctions.eHome;
        GVL.astAxes[iGapCentre].stControl.eCommand := E_MotionFunctions.eHome;
        GVL.astAxes[iGapSize].stControl.bExecute := TRUE;
        GVL.astAxes[iGapCentre].stControl.bExecute := TRUE;
        eSlitPairState := E_SlitPairStates.CHECK_GAP_HOME_COMPLETE;

    E_SlitPairStates.CHECK_GAP_HOME_COMPLETE: //Wait for virtual homing completion
        IF bGapHomed AND NOT GVL.astAxes[iGapSize].stStatus.bBusy AND NOT GVL.astAxes[iGapCentre].stStatus.bBusy THEN
            eSlitPairState := E_SlitPairStates.GEARIN_SLITS;
            bHomingRequested := FALSE;
        END_IF

    E_SlitPairStates.GEARIN_SLITS: //Setup gearing
        actSetupSlitGearing();
        eSlitPairState := E_SlitPairStates.CHECK_GEARIN_SLITS_COMPLETE;

    E_SlitPairStates.CHECK_GEARIN_SLITS_COMPLETE: //Wait for gearing complete
        IF bBladesCoupled THEN
            eSlitPairState := E_SlitPairStates.SLITS_OPERATIONAL;
        END_IF

    E_SlitPairStates.SLITS_OPERATIONAL: //SLITS OPERATIONAL - Monitor for any gear outs and re-gear when no busy blades
        bEnabled := TRUE;
        checkSoftLimits(); // Soft limits are updated when axes are stopped
        IF (NOT bBladesCoupled OR NOT bEnable) AND NOT GVL.astAxes[iBladeNegative].stStatus.bBusy AND NOT GVL.astAxes[iBladePositive].stStatus.bBusy THEN
            eSlitPairState := E_SlitPairStates.GEAROUT_BLADES;
        END_IF
        IF (GVL.astAxes[iGapSize].stControl.eCommand = E_MotionFunctions.eHome AND GVL.astAxes[iGapSize].stControl.bExecute) OR
        (GVL.astAxes[iGapCentre].stControl.eCommand = E_MotionFunctions.eHome AND GVL.astAxes[iGapCentre].stControl.bExecute) THEN
            eSlitPairState := E_SlitPairStates.GEAROUT_BLADES;
            bHomingRequested := TRUE;
        END_IF

    E_SlitPairStates.GEAROUT_BLADES: //Clear amy residual gearing
        actClearSlitGearing();
        eSlitPairState := E_SlitPairStates.CHECK_GEAROUT_COMPLETE;

    E_SlitPairStates.CHECK_GEAROUT_COMPLETE: //Check gearing cleared
        IF bBladesUncoupled THEN
            IF bHomingRequested THEN
                eSlitPairState := E_SlitPairStates.HOME_BLADES;
                bEnabled := FALSE;
            ELSE
                eSlitPairState := E_SlitPairStates.INIT;
            END_IF
        END_IF

    E_SlitPairStates.ERROR: //ERROR STATE
        resetCounterTimeout := 0;
        bError := TRUE;
        bEnabled := FALSE;
        actStopAxes();
        IF bReset THEN
            bResetting := TRUE;
            eSlitPairState := E_SlitPairStates.ERROR_GEAROUT;
        END_IF

    E_SlitPairStates.ERROR_GEAROUT: //Try to clear issues
        actClearSlitGearing();
        eSlitPairState := E_SlitPairStates.ERROR_GEAROUT_CHECK;

    E_SlitPairStates.ERROR_GEAROUT_CHECK:
        IF bBladesUncoupled THEN
            eSlitPairState := E_SlitPairStates.ERROR_RESET_AXES; //Back to homing, this ensures the setpoint position of the axis is updated.
        END_IF

    E_SlitPairStates.ERROR_RESET_AXES: //RESET ALL AXES
        GVL.astAxes[iBladeNegative].stControl.bReset := TRUE;
        GVL.astAxes[iBladePositive].stControl.bReset := TRUE;
        GVL.astAxes[iGapSize].stControl.bReset := TRUE;
        GVL.astAxes[iGapCentre].stControl.bReset := TRUE;
        resetCounterTimeout := resetCounterTimeout + 1;
        eSlitPairState := E_SlitPairStates.ERROR_RESET_CHECK;

    E_SlitPairStates.ERROR_RESET_CHECK:
        IF resetCounterTimeout > 10 THEN
            eSlitPairState := E_SlitPairStates.ERROR;
            bResetting := FALSE;
            RETURN;
        END_IF
        IF bAxisErrorsPresent THEN
            eSlitPairState := E_SlitPairStates.ERROR_RESET_AXES;
        ELSE
            eSlitPairState := E_SlitPairStates.INIT;
            bError := FALSE;
            bResetting := FALSE;
        END_IF
END_CASE

bReset := FALSE;
]]></ST>
    </Implementation>
    <Action Name="actClearSlitGearing" Id="{1b3caf4f-ddef-035c-06c2-b31f09d8bc8e}">
      <Implementation>
        <ST><![CDATA[//Action to send gearOut command to blade axes
GVL.astAxes[iBladeNegative].stControl.eCommand := E_MotionFunctions.eGearOut;
GVL.astAxes[iBladePositive].stControl.eCommand := E_MotionFunctions.eGearOut;
GVL.astAxes[iBladeNegative].stControl.bExecute := TRUE;
GVL.astAxes[iBladePositive].stControl.bExecute := TRUE;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actEnableAxes" Id="{1879c38a-aecf-0e8c-2a58-959e274ebc63}">
      <Implementation>
        <ST><![CDATA[
// Enable all axis when one of the virtual axes is enabled
fbEnableRising(CLK := GVL.astAxes[iGapSize].stControl.bEnable OR GVL.astAxes[iGapCentre].stControl.bEnable );

IF  fbEnableRising.Q THEN
    GVL.astAxes[iBladePositive].stControl.bEnable := TRUE;
    GVL.astAxes[iBladeNegative].stControl.bEnable := TRUE;
    GVL.astAxes[iGapSize].stControl.bEnable := TRUE;
    GVL.astAxes[iGapCentre].stControl.bEnable := TRUE;
    bEnable := TRUE;
END_IF


// Disable blade axes when both the virtuals are disabled
fbDisableRising(CLK := NOT GVL.astAxes[iGapSize].stControl.bEnable OR NOT GVL.astAxes[iGapCentre].stControl.bEnable );

IF fbDisableRising.Q THEN
    GVL.astAxes[iBladePositive].stControl.bEnable := FALSE;
    GVL.astAxes[iBladeNegative].stControl.bEnable := FALSE;
    GVL.astAxes[iGapSize].stControl.bEnable := FALSE;
    GVL.astAxes[iGapCentre].stControl.bEnable := FALSE;
END_IF

// Set Enable flag when all axes are enabled
bEnable := GVL.astAxes[iBladePositive].stStatus.bEnabled AND GVL.astAxes[iBladeNegative].stStatus.bEnabled
    AND GVL.astAxes[iGapSize].stStatus.bEnabled AND GVL.astAxes[iGapCentre].stStatus.bEnabled;

// Set flag when all axis are disable
fbDisabledRising(CLK := NOT GVL.astAxes[iBladePositive].stStatus.bEnabled AND GVL.astAxes[iBladeNegative].stStatus.bEnabled
    AND GVL.astAxes[iGapSize].stStatus.bEnabled AND GVL.astAxes[iGapCentre].stStatus.bEnabled);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actErrorHandling" Id="{d6af18ad-d698-0d90-0e47-da58345e8c10}">
      <Implementation>
        <ST><![CDATA[//Error handling for slit functionality
IF bResetting THEN //ignore setting in error state if FB going through a reset
    RETURN;
END_IF

// RESET - Use the reset from the virtual axes in order to reset the slits
bReset := GVL.astAxes[iGapCentre].stControl.bReset OR GVL.astAxes[iGapSize].stControl.bReset;

IF NOT bError AND bAxisErrorsPresent THEN
    eSlitPairState := E_SlitPairStates.ERROR;
END_IF
//IF eSlitPairState <> E_SlitPairStates.INIT AND NOT bAxesEnabled THEN
//    eSlitPairState := E_SlitPairStates.ERROR;
//END_IF
//IF (eSlitPairState <> E_SlitPairStates.INIT AND NOT bFunctionInErrorState) AND NOT bEnable THEN
//    eSlitPairState := E_SlitPairStates.ERROR;
//END_IF
IF bEnabled AND NOT bBladesHomed THEN
    eSlitPairState := E_SlitPairStates.ERROR;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actGapLimits" Id="{def3d604-4e23-0583-39ed-61c5876cfc85}">
      <Implementation>
        <ST><![CDATA[//Set Virtual axis inputs to TRUE to enable movement
GVL.astAxes[iGapSize].stInputs.bLimitBwd := GVL.astAxes[iBladeNegative].stInputs.bLimitFwd OR GVL.astAxes[iBladePositive].stInputs.bLimitBwd;
GVL.astAxes[iGapSize].stInputs.bLimitFwd := GVL.astAxes[iBladeNegative].stInputs.bLimitBwd OR GVL.astAxes[iBladePositive].stInputs.bLimitFwd;;
GVL.astAxes[iGapCentre].stInputs.bLimitBwd := GVL.astAxes[iBladeNegative].stInputs.bLimitFwd OR GVL.astAxes[iBladePositive].stInputs.bLimitBwd;;
GVL.astAxes[iGapCentre].stInputs.bLimitFwd :=GVL.astAxes[iBladeNegative].stInputs.bLimitBwd OR GVL.astAxes[iBladePositive].stInputs.bLimitFwd;;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actInterlocking" Id="{64063538-5b16-04d7-1d46-c493a7cc7a35}">
      <Implementation>
        <ST><![CDATA[//Blades interlocking for anticollition purposes
GVL.astAxes[iBladeNegative].stControl.bInterlockFwd := GVL.astAxes[iBladeNegative].stStatus.fActPosition >= GVL.astAxes[iBladePositive].stStatus.fActPosition
    OR GVL.astAxes[iBladeNegative].stControl.fPosition >= GVL.astAxes[iBladePositive].stStatus.fActPosition ;
GVL.astAxes[iBladePositive].stControl.bInterlockBwd := GVL.astAxes[iBladePositive].stStatus.fActPosition <= GVL.astAxes[iBladeNegative].stStatus.fActPosition
    OR GVL.astAxes[iBladePositive].stControl.fPosition <= GVL.astAxes[iBladeNegative].stStatus.fActPosition ;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actRunMethods" Id="{90ea6783-6879-04c9-30bf-2764a207cd0f}">
      <Implementation>
        <ST><![CDATA[checkAllAxesEnabled(bOutput => bAxesEnabled);
checkBladesHomed(bOutput => bBladesHomed);
checkVirtualHomed(bOutput => bGapHomed);
checkBladesCoupled(bOutput => bBladesCoupled);
checkBladesUncoupled(bOutput => bBladesUncoupled);
checkAllAxisErrors(bOutput => bAxisErrorsPresent);
checkErrorState(bOutput => bFunctionInErrorState);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actSetupSlitGearing" Id="{7713a838-7a24-0b22-0e20-e71c745ddc61}">
      <Implementation>
        <ST><![CDATA[GVL.astAxes[iBladeNegative].stControl.eCommand := E_MotionFunctions.eGearInMultiMaster;
GVL.astAxes[iBladeNegative].stConfig.astMultiMasterAxis[1].nIndex := iGapSize;
GVL.astAxes[iBladeNegative].stConfig.astMultiMasterAxis[1].fRatio := -0.5;
GVL.astAxes[iBladeNegative].stConfig.astMultiMasterAxis[2].nIndex := iGapCentre;
GVL.astAxes[iBladeNegative].stConfig.astMultiMasterAxis[2].fRatio := 1;
GVL.astAxes[iBladePositive].stControl.eCommand := E_MotionFunctions.eGearInMultiMaster;
GVL.astAxes[iBladePositive].stConfig.astMultiMasterAxis[1].nIndex := iGapSize;
GVL.astAxes[iBladePositive].stConfig.astMultiMasterAxis[1].fRatio := 0.5;
GVL.astAxes[iBladePositive].stConfig.astMultiMasterAxis[2].nIndex := iGapCentre;
GVL.astAxes[iBladePositive].stConfig.astMultiMasterAxis[2].fRatio := 1;
GVL.astAxes[iBladeNegative].stControl.bExecute := TRUE;
GVL.astAxes[iBladePositive].stControl.bExecute := TRUE;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actStopAxes" Id="{83b4f1fe-f696-016b-03db-3bcff9089f7d}">
      <Implementation>
        <ST><![CDATA[// Stop all axis when in error (Abort movements)
GVL.astAxes[iBladePositive].stControl.bStop := TRUE;
GVL.astAxes[iBladeNegative].stControl.bStop := TRUE;
GVL.astAxes[iGapSize].stControl.bStop := TRUE;
GVL.astAxes[iGapCentre].stControl.bStop := TRUE;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actUpdateSoftLimits" Id="{35e948c5-fa3a-0897-288a-c8995c0599d0}">
      <Implementation>
        <ST><![CDATA[// The solf limits of the virtual axes are updated everytime a movement has been accomplied.
// This is to avoid undesired errors if the user set a targe possition which is not allowed

CASE eSoftLimitsUpdate OF

E_SlitSoftLimits.START: //START SEQ Software limit center gap fwd (When not busy start)
    IF NOT GVL.astAxes[iGapCentre].stStatus.bBusy AND NOT GVL.astAxes[iGapSize].stStatus.bBusy THEN
        eSoftLimitsUpdate := E_SlitSoftLimits.WRITE_GAP_CENTRE_FWD;
        GVL.astAxes[iGapCentre].stControl.bExecute := TRUE;
        GVL.astAxes[iGapCentre].stControl.eCommand := E_MotionFunctions.eWriteParameter;
        GVL.astAxes[iGapCentre].stConfig.eAxisParameters := E_AxisParameters.SWLimitForward;
        GVL.astAxes[iGapCentre].stConfig.fWriteAxisParameter := (GVL.astAxes[iBladePositive].stConfig.fMaxSoftPosLimit
        - GVL.astAxes[iGapSize].stStatus.fActPosition/2);
    END_IF

E_SlitSoftLimits.WRITE_GAP_CENTRE_FWD: //WRITE GAP CENTRE FWD SOFT LIMIT DONE. Calculate software limit center gap bwd
    IF GVL.astAxes[iGapCentre].stStatus.bDone AND NOT GVL.astAxes[iGapCentre].stControl.bExecute THEN
        eSoftLimitsUpdate := E_SlitSoftLimits.WRITE_GAP_CENTRE_BWD;
        GVL.astAxes[iGapCentre].stControl.bExecute := TRUE;
        GVL.astAxes[iGapCentre].stControl.eCommand := E_MotionFunctions.eWriteParameter;
        GVL.astAxes[iGapCentre].stConfig.eAxisParameters := E_AxisParameters.SWLimitBackward;
        GVL.astAxes[iGapCentre].stConfig.fWriteAxisParameter := (GVL.astAxes[iBladeNegative].stConfig.fMinSoftPosLimit
        + GVL.astAxes[iGapSize].stStatus.fActPosition/2);
    END_IF

E_SlitSoftLimits.WRITE_GAP_CENTRE_BWD: //WRITE GAP CENTRE BWD SOFT LIMIT DONE. Calculate software limit gap size fwd
    IF GVL.astAxes[iGapCentre].stStatus.bDone AND NOT GVL.astAxes[iGapCentre].stControl.bExecute THEN
        eSoftLimitsUpdate := E_SlitSoftLimits.WRITE_GAP_SIZE_FWD;
        GVL.astAxes[iGapSize].stControl.bExecute := TRUE;
        GVL.astAxes[iGapSize].stControl.eCommand := E_MotionFunctions.eWriteParameter;
        GVL.astAxes[iGapSize].stConfig.eAxisParameters := E_AxisParameters.SWLimitForward;
        IF GVL.astAxes[iGapCentre].stStatus.fActPosition >= 0.0 THEN
                GVL.astAxes[iGapSize].stConfig.fWriteAxisParameter := 2 * ABS(GVL.astAxes[iBladePositive].stConfig.fMaxSoftPosLimit
                    - GVL.astAxes[iGapCentre].stStatus.fActPosition);
        ELSE
                GVL.astAxes[iGapSize].stConfig.fWriteAxisParameter := 2 * ABS(GVL.astAxes[iBladeNegative].stConfig.fMinSoftPosLimit
                    - GVL.astAxes[iGapCentre].stStatus.fActPosition);
        END_IF
    END_IF

E_SlitSoftLimits.WRITE_GAP_SIZE_FWD: //WRITE GAP SIZE FWD SOFT LIMIT DONE.

    IF GVL.astAxes[iGapSize].stStatus.bDone AND NOT GVL.astAxes[iGapSize].stControl.bExecute THEN
            eSoftLimitsUpdate := E_SlitSoftLimits.START;
            bUpdateSoftLimits := FALSE;
    END_IF

END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisPositions" Id="{7f6698b5-ef89-01d2-091a-1167e8f62f6e}">
      <Implementation>
        <ST><![CDATA[(*Calculate virtual axis positions and convert to UDINT.
Conversion to UDINT is prohibited if it would exceed UDINT max value of 4,294,967,295.
If this is not done, it can cause overflow when connected to the encoder input and hard-crash the PLC which will only recover with a power cycle.
To preserve decimal position data of the LREAL (i.e. anything <1mm) it is necessary to scale the value before converting to UDINT.
This can be reversed with the correct scaling at the NC encoder level.
*)
fGapSizePosition := GVL.astAxes[iBladePositive].stStatus.fActPosition - GVL.astAxes[iBladeNegative].stStatus.fActPosition;
fGapCentrePosition := (GVL.astAxes[iBladePositive].stStatus.fActPosition + GVL.astAxes[iBladeNegative].stStatus.fActPosition) / 2;

IF bBladesHomed THEN
    IF ABS(fGapSizePosition) < 100000 THEN
        iGapSizePosition := LREAL_TO_UDINT(fGapSizePosition*fEncoderScaling);
    END_IF
    IF ABS(fGapCentrePosition) < 100000 THEN
        iGapCentrePosition := LREAL_TO_UDINT(fGapCentrePosition*fEncoderScaling);
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Method Name="checkAllAxesEnabled" Id="{68815ab2-933a-0cf6-0de8-cc7494d09118}">
      <Declaration><![CDATA[(*Method to check if all axes (real and virtual) are enabled.
Only returns TRUE if BOTH blades are homed*)
METHOD checkAllAxesEnabled: BOOL
VAR_OUTPUT
    bOutput: BOOL:= TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT GVL.astAxes[iBladeNegative].stStatus.bEnabled THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iBladePositive].stStatus.bEnabled THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iGapSize].stStatus.bEnabled THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iGapCentre].stStatus.bEnabled THEN
    bOutput := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkAllAxisErrors" Id="{38d2d046-b549-0765-1487-87302195ffc6}">
      <Declaration><![CDATA[(*Method to check if an error is present on any axis.
Returns TRUE if an error is present on any axis *)
METHOD checkAllAxisErrors: BOOL
VAR_OUTPUT
    bOutput: BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL.astAxes[iGapSize].stStatus.bError THEN
    bOutput := TRUE;
END_IF
IF GVL.astAxes[iGapCentre].stStatus.bError THEN
    bOutput := TRUE;
END_IF
IF GVL.astAxes[iBladeNegative].stStatus.bError THEN
    bOutput := TRUE;
END_IF
IF GVL.astAxes[iBladePositive].stStatus.bError THEN
    bOutput := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkBladesCoupled" Id="{4d5a8473-6708-0035-3843-638ffe259036}">
      <Declaration><![CDATA[(*Method to check if both blades are coupled to the virtual axes.
Only returns TRUE if BOTH blades are coupled *)
METHOD checkBladesCoupled: BOOL
VAR_OUTPUT
    bOutput: BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT GVL.astAxes[iBladeNegative].stStatus.bGeared THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iBladePositive].stStatus.bGeared THEN
    bOutput := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkBladesHomed" Id="{81c53f0d-71e1-0f29-1da7-da19807b67a4}">
      <Declaration><![CDATA[(*Method to check if blade axes are homed/have the calibration flag.
Only returns TRUE if BOTH blades are homed*)
METHOD checkBladesHomed: BOOL
VAR_OUTPUT
    bOutput: BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT GVL.astAxes[iBladeNegative].stStatus.bHomed THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iBladePositive].stStatus.bHomed THEN
    bOutput := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkBladesUncoupled" Id="{c279ba5c-ed4a-0e71-2fa2-767db0f1b8c8}">
      <Declaration><![CDATA[(*Method to check if both blades are uncoupled from the virtual axes.
Only returns TRUE if BOTH blades are uncoupled *)
METHOD checkBladesUncoupled: BOOL
VAR_OUTPUT
    bOutput: BOOL:= TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF GVL.astAxes[iBladeNegative].stStatus.bGeared THEN
    bOutput := FALSE;
END_IF
IF GVL.astAxes[iBladePositive].stStatus.bGeared THEN
    bOutput := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkErrorState" Id="{d319af0e-09fa-07f8-1865-7465aecd1eae}">
      <Declaration><![CDATA[METHOD checkErrorState: BOOL
VAR_OUTPUT
    bOutput: BOOL := FALSE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF eSlitPairState = E_SlitPairStates.ERROR THEN
    bOutput := TRUE;
END_IF
IF eSlitPairState = E_SlitPairStates.ERROR_GEAROUT THEN
    bOutput := TRUE;
END_IF
IF eSlitPairState = E_SlitPairStates.ERROR_GEAROUT_CHECK THEN
    bOutput := TRUE;
END_IF
IF eSlitPairState = E_SlitPairStates.ERROR_RESET_AXES THEN
    bOutput := TRUE;
END_IF
IF eSlitPairState = E_SlitPairStates.ERROR_RESET_CHECK THEN
    bOutput := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkSlitsHomed" Id="{79b1cda9-2126-0e81-3df4-233ef39e0b6e}">
      <Declaration><![CDATA[(*Method to check if blade axes are homed/have the calibration flag.
Only returns TRUE if BOTH blades are homed*)
METHOD checkSlitsHomed: BOOL
VAR_OUTPUT
    bOutput: BOOL := TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbHomingRising(CLK:= GVL.astAxes[iBladeNegative].stStatus.bHomed AND GVL.astAxes[iBladePositive].stStatus.bHomed AND GVL.astAxes[iGapSize].stStatus.bHomed AND GVL.astAxes[iGapCentre].stStatus.bHomed  );
IF fbHomingRising.Q THEN
    bOutput := FALSE;
    bSlitsHomed := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkSoftLimits" Id="{7b17dbf3-e1d6-0a6e-1aa4-6cded47f1f4b}">
      <Declaration><![CDATA[METHOD checkSoftLimits : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbNoMovingRising(CLK := NOT GVL.astAxes[iGapCentre].stStatus.bMoving AND NOT GVL.astAxes[iGapSize].stStatus.bMoving);
fbInOpRising(CLK := eSlitPairState = E_SlitPairStates.SLITS_OPERATIONAL);

IF fbNoMovingRising.Q OR fbInOpRising.Q THEN
    bUpdateSoftLimits := TRUE;
END_IF

IF bUpdateSoftLimits THEN
    actUpdateSoftLimits();
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="checkVirtualHomed" Id="{4449923d-b61f-063b-337f-e765d5643490}">
      <Declaration><![CDATA[(*Method to check if the virtual axes for gap size and gap centre are homed/the calibration flag is present.
Only returns TRUE if BOTH virtual axes are homed *)
METHOD checkVirtualHomed: BOOL
VAR_OUTPUT
    bOutput: BOOL:= TRUE;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT GVL.astAxes[iGapSize].stStatus.bHomed THEN
    bOutput := FALSE;
END_IF
IF NOT GVL.astAxes[iGapCentre].stStatus.bHomed THEN
    bOutput := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>