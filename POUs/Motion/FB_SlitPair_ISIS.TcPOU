<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_SlitPair_ISIS" Id="{b3c09412-d9b8-4fdb-95f8-f2ca5d9e6945}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_SlitPair_ISIS
VAR_INPUT
    nIdPositiveAxis: UINT; //ID of axis for which positive motion increases gap size
    nIdNegativeAxis: UINT; //ID of axis for which negative motion increases gap size
    nIdGapSizeAxis: UINT; //ID of virtual gap aperture size axis
    nIdGapCentreAxis: UINT; //ID of virtual gap centre position axis

    bEnable: BOOL; //Enable slit pair logic functionality
    bReset: BOOL; //Reset from error state
    fEncoderScaling: LREAL := 10000; //Virtual axis scaling denominator, default of 10000



END_VAR

//Linkable objects
VAR
    //Replacement limit links for real axes
    bPositiveAxis_FwdLimit AT %I* : BOOL;
    bPositiveAxis_BwdLimit AT %I* : BOOL;
    bNegativeAxis_FwdLimit AT %I* : BOOL;
    bNegativeAxis_BwdLimit AT %I* : BOOL;

    //Software encoders for virtual axes
    nGapSizeEncoder AT %Q*: UDINT := 0;
    nGapCentreEncoder AT %Q*: UDINT := 0;
END_VAR

VAR
    fGapSize: LREAL;
    fGapCentre: LREAL;

    bAllHalted: BOOL := FALSE;
    bInternalResetHome: BOOL :=FALSE;

    fbSetpointGenEnablePositiveAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableNegativeAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableGapSizeAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableGapCentreAxis: MC_ExtSetPointGenEnable;

    fbSetpointGenDisablePositiveAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableNegativeAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableGapSizeAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableGapCentreAxis: MC_ExtSetPointGenDisable;

    fPosSetpointPositiveAxis: LREAL;
    fPosSetpointNegativeAxis: LREAL;
    fPosSetpointGapSizeAxis: LREAL;
    fPosSetpointGapCentreAxis: LREAL;

    fPosSetpointPositiveAxis_Nominal: LREAL;
    fPosSetpointNegativeAxis_Nominal: LREAL;
    fPosSetpointGapSizeAxis_Nominal: LREAL;
    fPosSetpointGapCentreAxis_Nominal: LREAL;

    fVeloSetpointPositiveAxis: LREAL;
    fVeloSetpointNegativeAxis: LREAL;
    fVeloSetpointGapSizeAxis: LREAL;
    fVeloSetpointGapCentreAxis: LREAL;

    fVeloSetpointPositiveAxis_Nominal: LREAL;
    fVeloSetpointNegativeAxis_Nominal: LREAL;
    fVeloSetpointGapSizeAxis_Nominal: LREAL;
    fVeloSetpointGapCentreAxis_Nominal: LREAL;

    nDirectionPositiveAxis: DINT;
    nDirectionNegativeAxis: DINT;
    nDirectionGapSizeAxis: DINT;
    nDirectionGapCentreAxis: DINT;
    
    VELOCITY_DIRECTION_THRESHOLD : LREAL := 0.05;

    ePositiveAxisState : E_AxisLimitState;
    eNegativeAxisState : E_AxisLimitState;
    eAxisPairState : E_SlitPairLimitState;


    eState: E_SlitPairStates := E_SlitPairStates.eInit;

    bInternalReset: BOOL;
    bHomingReset: BOOL := FALSE;

    //Two resets required due to homing functionality
    bResetInProgressCheck1: BOOL := FALSE;
    bResetInProgressCheck2: BOOL := FALSE;

    //internal MC_Reset, needed because the current reset in FB_Axis works only when there is an error. This should change once the reset functionality changes
    fbInternalResetTrig: R_TRIG;
    fbInternalResetHome: R_TRIG;
    fbResetPositiveAxis: MC_RESET;
    fbResetNegativeAxis: MC_RESET;
    fbResetGapSizeAxis: MC_RESET;
    fbResetGapCentreAxis: MC_RESET;
    fbResetHomedGap: MC_Home;
    fbResetHomedCentre: MC_Home;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*SETUP INSTRUCTIONS
    All Axes:
        Allow motion commands to external setpoint axis := FALSE;
    Real Axes:
        Do not link limit switches to astAxes struct. Limits must be linked to FB_SlitPair_ISIS inputs
    Virtual axes:
        Encoder type set to Encoder (universal)
        Encoder mask set to 0xFFFFFFFF
        Encoder numerator/denominator scaling set to match FB fEncoderScaling value (default of 10 000 results in numerator of 0.0001 with denominator of 1)
        Link nDataIn1 of encoder to FB encoders
        Position lag monitoring can be left on
        Dynamics of virtual axes must be configured considering coupled mechanicals (e.g. don't set velocities your real axes can't achieve)
*)

//Limit switch passthrough by default - overridden where required in later logic to satisfy ExternalSetpointGenerators
GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= bPositiveAxis_FwdLimit;
GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= bPositiveAxis_BwdLimit;
GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= bNegativeAxis_FwdLimit;
GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= bNegativeAxis_BwdLimit;
GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitFwd:= TRUE;
GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitBwd:= TRUE;
GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitFwd:= TRUE;
GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitBwd:= TRUE;

//Enable Logic - Virtual axes automatically enable when real axes are enabled
actVirtualAxisEnable();

//Position of virtual axes
actVirtualAxisPositions();

//Determine limit state of real axes
actLimitState();

//Set fwEnabled and bwEnabled of virtual axes
actVirtualAxisLimits();

//Calculate position and velocity setpoints
actCalculateSetpointPositionAndVelocity();

//Calculate direction setpoints
actCalculateSetpointDirections();




//Error state handling - only handle errors that disable motion
IF bEnable AND (GVL.astAxes[nIdPositiveAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdNegativeAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    eState := E_SlitPairStates.eError;
END_IF

//Propagate real axis error to virtual
IF GVL.astAxes[nIdPositiveAxis].Axis.Status.ErrorStop AND (NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR NOT GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    GVL.astAxes[nIdGapSizeAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.nErrorID := GVL.astAxes[nIdPositiveAxis].stStatus.nErrorID;
    GVL.astAxes[nIdGapCentreAxis].stStatus.nErrorID := GVL.astAxes[nIdPositiveAxis].stStatus.nErrorID;
ELSIF  GVL.astAxes[nIdNegativeAxis].Axis.Status.ErrorStop AND (NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR NOT GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    GVL.astAxes[nIdGapSizeAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.nErrorID := GVL.astAxes[nIdNegativeAxis].stStatus.nErrorID;
    GVL.astAxes[nIdGapCentreAxis].stStatus.nErrorID := GVL.astAxes[nIdNegativeAxis].stStatus.nErrorID;
END_IF

//Internal Reset linked to any axis reset
bInternalReset := bReset OR GVL.astAxes[nIdPositiveAxis].stControl.bReset OR GVL.astAxes[nIdNegativeAxis].stControl.bReset OR GVL.astAxes[nIdGapSizeAxis].stControl.bReset OR GVL.astAxes[nIdGapCentreAxis].stControl.bReset;

//If real axis is homing, change state
IF bEnable AND (GVL.astAxes[nIdPositiveAxis].Axis.Status.HomingBusy OR GVL.astAxes[nIdNegativeAxis].Axis.Status.HomingBusy) THEN
    eState := E_SlitPairStates.eWaitForRealHomed;
END_IF

//Link all halt buttons in motors
IF GVL.astAxes[nIdPositiveAxis].stControl.bHalt OR GVL.astAxes[nIdNegativeAxis].stControl.bHalt OR
    GVL.astAxes[nIdGapSizeAxis].stControl.bHalt OR GVL.astAxes[nIdGapCentreAxis].stControl.bHalt THEN
    actHaltAllAxes();   //Will upset setpoint generator axes - may be able to fix by only issuing to non-setpoint generated axes
END_IF

//Propagate homing status
fbResetHomedGap(Axis:= GVL.astAxes[nIdGapSizeAxis].Axis, HomingMode:= MC_ResetCalibration);
fbResetHomedCentre(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis, HomingMode:= MC_ResetCalibration);
fbInternalResetHome(CLK:= fbResetHomedCentre.Done OR fbResetHomedGap.Done );

IF NOT GVL.astAxes[nIdPositiveAxis].stStatus.bHomed OR NOT GVL.astAxes[nIdNegativeAxis].stStatus.bHomed THEN
        fbResetHomedGap.Execute := TRUE;
        fbResetHomedCentre.Execute := TRUE;
END_IF

IF fbInternalResetHome.Q THEN
        fbResetHomedGap.Execute := FALSE;
        fbResetHomedCentre.Execute := FALSE;
END_IF


//State machine
IF bEnable THEN
    CASE eState OF  //HOMING LOOP ISSUE
        E_SlitPairStates.eInit:
            //If real axes are calibrated, then home the virtual axes, else go Operatioanl
            fbResetPositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis, Execute:=FALSE);
            fbResetNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis, Execute:=FALSE);
            fbResetGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis, Execute:=FALSE);
            fbResetGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis, Execute:=FALSE);
            IF GVL.astAxes[nIdPositiveAxis].stStatus.bHomed AND GVL.astAxes[nIdNegativeAxis].stStatus.bHomed THEN
               GVL.astAxes[nIdGapSizeAxis].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
               GVL.astAxes[nIdGapCentreAxis].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
               GVL.astAxes[nIdGapSizeAxis].stConfig.fHomePosition := fGapSize;
               GVL.astAxes[nIdGapCentreAxis].stConfig.fHomePosition := fGapCentre;
                eState := E_SlitPairStates.eWaitForVirtualHomed;
            ELSE
                eState := E_SlitPairStates.eOperational;
            END_IF

        E_SlitPairStates.eWaitForVirtualHomed:
            //Wait for virtual axis homing to complete/
            GVL.astAxes[nIdGapSizeAxis].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[nIdGapSizeAxis].stControl.bExecute := TRUE;
            GVL.astAxes[nIdGapCentreAxis].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[nIdGapCentreAxis].stControl.bExecute := TRUE;
            IF GVL.astAxes[nIdGapSizeAxis].stStatus.bHomed AND GVL.astAxes[nIdGapCentreAxis].stStatus.bHomed THEN
                eState := E_SlitPairStates.eOperational;
            END_IF
            //IF NOT IN HOMING STATE

        E_SlitPairStates.eOperational:
            bResetInProgressCheck1 := FALSE;
            //Detect whether real or virtual axes are moving
            IF GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving OR GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving THEN
                eState := E_SlitPairStates.eEnableRealGenerators;
            END_IF
            IF GVL.astAxes[nIdPositiveAxis].stStatus.bMoving OR GVL.astAxes[nIdNegativeAxis].stStatus.bMoving THEN
                eState := E_SlitPairStates.eEnableVirtualGenerators;
            END_IF

        E_SlitPairStates.eEnableRealGenerators:
            //Temporary override of limits
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= TRUE;
            fbSetpointGenEnablePositiveAxis.Execute := TRUE;
            fbSetpointGenEnableNegativeAxis.Execute := TRUE;
            eState := E_SlitPairStates.eCheckRealAxisGeneratorsEnabled;

        E_SlitPairStates.eCheckRealAxisGeneratorsEnabled:
            //Hold MC_Power on until generators have enabled
            IF fbSetpointGenEnablePositiveAxis.Enabled AND fbSetpointGenEnableNegativeAxis.Enabled THEN
                eState := E_SlitPairStates.eWaitForVirtualMoveDone;
            END_IF

        E_SlitPairStates.eWaitForVirtualMoveDone:
            IF NOT(GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving OR GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving) THEN
                eState := E_SlitPairStates.eDisableGenerators;
            END_IF

        E_SlitPairStates.eDisableGenerators:
            fbSetpointGenDisablePositiveAxis.Execute := TRUE;
            fbSetpointGenDisableNegativeAxis.Execute := TRUE;
            fbSetpointGenDisableGapCentreAxis.Execute := TRUE;
            fbSetpointGenDisableGapSizeAxis.Execute := TRUE;
            eState := E_SlitPairStates.eOperational;

        E_SlitPairStates.eEnableVirtualGenerators:
            //Hold MC_Power on until generators have enabled
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= TRUE;
            fbSetpointGenEnableGapSizeAxis.Execute := TRUE;
            fbSetpointGenEnableGapCentreAxis.Execute := TRUE;
            eState := E_SlitPairStates.eCheckVirtualAxisGeneratorsEnabled;

        E_SlitPairStates.eCheckVirtualAxisGeneratorsEnabled:
            //Hold MC_Power on until generators have enabled
            IF fbSetpointGenEnableGapSizeAxis.Enabled AND fbSetpointGenEnableGapCentreAxis.Enabled THEN
                eState := E_SlitPairStates.eWaitForRealMoveDone;
            END_IF

        E_SlitPairStates.eWaitForRealMoveDone:
            IF NOT(GVL.astAxes[nIdPositiveAxis].stStatus.bMoving OR GVL.astAxes[nIdNegativeAxis].stStatus.bMoving) THEN
                eState := E_SlitPairStates.eDisableGenerators;
            END_IF

        E_SlitPairStates.eError:
            actHaltAllAxes();

            IF bHomingReset THEN
                bInternalReset := TRUE;
                bResetInProgressCheck1 := TRUE;
                bResetInProgressCheck2 := TRUE;
                bHomingReset := FALSE;
            END_IF
            IF bInternalReset OR bReset OR bResetInProgressCheck2 THEN
                fbResetPositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis, Execute:=TRUE);
                fbResetNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis, Execute:=TRUE);
                fbResetGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis, Execute:=TRUE);
                fbResetGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis, Execute:=TRUE);
                GVL.astAxes[nIdPositiveAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdNegativeAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdGapSizeAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdGapCentreAxis].stControl.bReset := TRUE;
                IF NOT(bResetInProgressCheck1) THEN
                    bResetInProgressCheck2 := FALSE;
                END_IF
            END_IF

            IF NOT(GVL.astAxes[nIdPositiveAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdNegativeAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdGapSizeAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdGapCentreAxis].stStatus.bError) THEN
                eState := E_SlitPairStates.eInit;
            END_IF

        E_SlitPairStates.eWaitForRealHomed:
            bHomingReset := TRUE;
            IF NOT GVL.astAxes[nIdPositiveAxis].Axis.Status.Homed OR NOT GVL.astAxes[nIdNegativeAxis].Axis.Status.Homed THEN
                eState := E_SlitPairStates.eInit;
            END_IF
    END_CASE
END_IF

//Call spGenerator FBs
actGeneratorEnableDisable();

//Feed externalsetpoint generators setpoint values - ignoring acceleration
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdPositiveAxis].Axis, Position:= fPosSetpointPositiveAxis, Velocity:= fVeloSetpointPositiveAxis, Acceleration:= 0, Direction:= nDirectionPositiveAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdNegativeAxis].Axis, Position:= fPosSetpointNegativeAxis, Velocity:= fVeloSetpointNegativeAxis, Acceleration:= 0, Direction:= nDirectionNegativeAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdGapSizeAxis].Axis, Position:= fPosSetpointGapSizeAxis, Velocity:= fVeloSetpointGapSizeAxis, Acceleration:= 0, Direction:= nDirectionGapSizeAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis, Position:= fPosSetpointGapCentreAxis, Velocity:= fVeloSetpointGapCentreAxis, Acceleration:= 0, Direction:= nDirectionGapCentreAxis);

bReset := FALSE;]]></ST>
    </Implementation>
    <Folder Name="Setpoint_Generator_Actions" Id="{8e494922-e7c2-4daa-80b3-ea89aa78df74}" />
    <Action Name="actCalculateSetpointDirections" Id="{5abf4283-d432-4b19-be96-a15b54858b40}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[IF fVeloSetpointPositiveAxis > VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionPositiveAxis := 1; //moving forward
ELSIF fVeloSetpointPositiveAxis < -VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionPositiveAxis := -1; //moving backward
ELSE
    nDirectionPositiveAxis := 0; //stationary
END_IF

IF fVeloSetpointNegativeAxis > VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionNegativeAxis := 1; //moving forward
ELSIF fVeloSetpointNegativeAxis < -VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionNegativeAxis := -1; //moving backward
ELSE
    nDirectionNegativeAxis := 0; //stationary
END_IF

IF fVeloSetpointGapSizeAxis > VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionGapSizeAxis := 1; //moving forward
ELSIF fVeloSetpointGapSizeAxis < -VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionGapSizeAxis := -1; //moving backward
ELSE
    nDirectionGapSizeAxis := 0; //stationary
END_IF

IF fVeloSetpointGapCentreAxis > VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionGapCentreAxis := 1; //moving forward
ELSIF fVeloSetpointGapCentreAxis < -VELOCITY_DIRECTION_THRESHOLD THEN
    nDirectionGapCentreAxis := -1; //moving backward
ELSE
    nDirectionGapCentreAxis := 0; //stationary
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actCalculateSetpointPositionAndVelocity" Id="{1756795d-6a25-4bcd-9ca1-dcd9ccd9b4a7}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[//Axis status update to get current NC move progress
GVL.astAxes[nIdPositiveAxis].Axis.ReadStatus();
GVL.astAxes[nIdNegativeAxis].Axis.ReadStatus();
GVL.astAxes[nIdGapSizeAxis].Axis.ReadStatus();
GVL.astAxes[nIdGapCentreAxis].Axis.ReadStatus();


//Calculate nominal setpoint positions assuming no limits
fPosSetpointPositiveAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetPos + (GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos/2);
fPosSetpointNegativeAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetPos - (GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos/2);
fPosSetpointGapSizeAxis_Nominal := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos;
fPosSetpointGapCentreAxis_Nominal := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos) / 2;

//Calculate nominal setpoint velocities assuming no limits
fVeloSetpointPositiveAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetVelo +(GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo/2);
fVeloSetpointNegativeAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetVelo -(GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo/2);
fVeloSetpointGapSizeAxis_Nominal := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetVelo - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetVelo;
fVeloSetpointGapCentreAxis_Nominal := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetVelo + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetVelo;


//Detect IF moving in Virtual axis gap control mode
IF GVL.astAxes[nIdPositiveAxis].Axis.Status.ExtSetPointGenEnabled OR GVL.astAxes[nIdNegativeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    //IF gap size getting bigger
    IF GVL.astAxes[nIdGapSizeAxis].Axis.Status.PositiveDirection THEN
        CASE eAxisPairState OF
        E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:   Setpoint_PositiveDisabled();
        E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:  Setpoint_AllDisabled();
        E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:   Setpoint_PositiveDisabled();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:  Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward: Setpoint_NegativeDisabled();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:  Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:   Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:  Setpoint_NegativeDisabled();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:   Setpoint_Normal();
        END_CASE
    //IF gap size getting smaller
    ELSIF GVL.astAxes[nIdGapSizeAxis].Axis.Status.NegativeDirection THEN
        CASE eAxisPairState OF
        E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:   Setpoint_NegativeDisabled();
        E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:  Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:   Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:  Setpoint_AllDisabled();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward: Setpoint_PositiveDisabled();
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:  Setpoint_PositiveDisabled();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:   Setpoint_NegativeDisabled();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:  Setpoint_Normal();
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:   Setpoint_Normal();
        END_CASE
    ELSE //Gap size axis is stationary
        //IF gap centre moving in positive direction
        IF GVL.astAxes[nIdGapCentreAxis].Axis.Status.PositiveDirection THEN
            CASE eAxisPairState OF
            E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:   Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:   Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward: Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:  Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:   Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:  Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:   Setpoint_Normal();
            END_CASE
        //IF gap centre moving in negative direction
        ELSIF GVL.astAxes[nIdGapCentreAxis].Axis.Status.NegativeDirection THEN
            CASE eAxisPairState OF
            E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:   Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:   Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward: Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:   Setpoint_Normal();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:  Setpoint_AllDisabled();
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:   Setpoint_Normal();
            END_CASE
        END_IF
    END_IF
END_IF

//Detect IF real axis control. Normal operation as no limits on virtual axes
IF GVL.astAxes[nIdGapCentreAxis].Axis.Status.ExtSetPointGenEnabled AND GVL.astAxes[nIdGapSizeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    fPosSetpointGapSizeAxis := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos;
    fPosSetpointGapCentreAxis := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos) / 2;
    fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_Nominal;
    fVeloSetpointGapSizeAxis := fVeloSetpointGapSizeAxis_Nominal;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actGeneratorEnableDisable" Id="{3488c74c-bc18-48be-a44b-85fc45e9d726}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[
fbSetpointGenEnablePositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis);
fbSetpointGenEnablePositiveAxis.Execute := FALSE;

fbSetpointGenEnableNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis);
fbSetpointGenEnableNegativeAxis.Execute := FALSE;

fbSetpointGenEnableGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis);
fbSetpointGenEnableGapSizeAxis.Execute := FALSE;

fbSetpointGenEnableGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis);
fbSetpointGenEnableGapCentreAxis.Execute := FALSE;


fbSetpointGenDisablePositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis);
fbSetpointGenDisablePositiveAxis.Execute := FALSE;

fbSetpointGenDisableNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis);
fbSetpointGenDisableNegativeAxis.Execute := FALSE;

fbSetpointGenDisableGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis);
fbSetpointGenDisableGapSizeAxis.Execute := FALSE;

fbSetpointGenDisableGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis);
fbSetpointGenDisableGapCentreAxis.Execute := FALSE;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHaltAllAxes" Id="{b7970e1d-c1fa-487e-a0a7-5d7f0550df46}">
      <Implementation>
        <ST><![CDATA[
bAllHalted := TRUE;

IF NOT GVL.astAxes[nIdPositiveAxis].Axis.Status.ExtSetPointGenEnabled THEN
    GVL.astAxes[nIdPositiveAxis].stControl.bHalt := TRUE;
END_IF
IF NOT GVL.astAxes[nIdNegativeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    GVL.astAxes[nIdNegativeAxis].stControl.bHalt := TRUE;
END_IF
IF NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    GVL.astAxes[nIdGapSizeAxis].stControl.bHalt := TRUE;
END_IF
IF NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    GVL.astAxes[nIdGapSizeAxis].stControl.bHalt := TRUE;
END_IF

//Reset Halts
IF bAllHalted AND NOT GVL.astAxes[nIdPositiveAxis].stStatus.bMoving AND NOT GVL.astAxes[nIdNegativeAxis].stStatus.bMoving
 AND NOT GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving AND NOT GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving THEN
   GVL.astAxes[nIdPositiveAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdNegativeAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdGapSizeAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdGapCentreAxis].stControl.bHalt := FALSE;
   bAllHalted := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actLimitState" Id="{0bf1ea49-b548-4e60-a8eb-6a1e52eb2a32}">
      <Implementation>
        <ST><![CDATA[//Positive axis state
IF bPositiveAxis_FwdLimit = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF bPositiveAxis_BwdLimit = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    ePositiveAxisState := E_AxisLimitState.NoLimit;
END_IF

//Negative axis state
IF bNegativeAxis_FwdLimit = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF bNegativeAxis_BwdLimit = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    eNegativeAxisState := E_AxisLimitState.NoLimit;
END_IF

//Combined slit pair limit state
CASE ePositiveAxisState OF
    E_AxisLimitState.OnForwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit;
        END_CASE
    E_AxisLimitState.OnBackwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit;
        END_CASE
    E_AxisLimitState.NoLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit;
        END_CASE
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisEnable" Id="{9800ad84-33b1-45e1-8f1c-18ce4e663f2f}">
      <Implementation>
        <ST><![CDATA[GVL.astAxes[nIdGapSizeAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stControl.bEnable AND GVL.astAxes[nIdNegativeAxis].stControl.bEnable;
GVL.astAxes[nIdGapCentreAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stControl.bEnable AND GVL.astAxes[nIdNegativeAxis].stControl.bEnable;]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisLimits" Id="{b46f168f-6065-4588-af1f-8e4bf3d9b991}">
      <Implementation>
        <ST><![CDATA[//Gap size forward limit
IF GVL.astAxes[nIdPositiveAxis].stStatus.bFwEnabled = FALSE AND GVL.astAxes[nIdNegativeAxis].stStatus.bBwEnabled = FALSE THEN
    GVL.astAxes[nIdGapSizeAxis].stStatus.bFwEnabled := FALSE;
ELSE
    GVL.astAxes[nIdGapSizeAxis].stStatus.bFwEnabled := TRUE;
END_IF

//Gap size backward limit
IF GVL.astAxes[nIdPositiveAxis].stStatus.bBwEnabled = FALSE AND GVL.astAxes[nIdNegativeAxis].stStatus.bFwEnabled = FALSE THEN
    GVL.astAxes[nIdGapSizeAxis].stStatus.bBwEnabled := FALSE;
ELSE
    GVL.astAxes[nIdGapSizeAxis].stStatus.bBwEnabled := TRUE;
END_IF

//Gap centre forward limit
IF GVL.astAxes[nIdPositiveAxis].stStatus.bFwEnabled = FALSE OR GVL.astAxes[nIdNegativeAxis].stStatus.bFwEnabled = FALSE THEN
    GVL.astAxes[nIdGapCentreAxis].stStatus.bFwEnabled := FALSE;
ELSE
    GVL.astAxes[nIdGapCentreAxis].stStatus.bFwEnabled := TRUE;
END_IF

//Gap centre backward limit
IF GVL.astAxes[nIdPositiveAxis].stStatus.bBwEnabled = FALSE OR GVL.astAxes[nIdNegativeAxis].stStatus.bBwEnabled = FALSE THEN
    GVL.astAxes[nIdGapCentreAxis].stStatus.bBwEnabled := FALSE;
ELSE
    GVL.astAxes[nIdGapCentreAxis].stStatus.bBwEnabled := TRUE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisPositions" Id="{728f3665-a1f5-47e1-9096-f32eff42a946}">
      <Implementation>
        <ST><![CDATA[(*Calculate virtual axis positions and convert to UDINT.
Conversion to UDINT is prohibited if it would exceed UDINT max value of 4,294,967,295.
If this is not done, it can cause overflow when connected to the encoder input and hard-crash the PLC which will only recover with a power cycle.
To preserve decimal position data of the LREAL (i.e. anything <1mm) it is necessary to scale the value before converting to UDINT.
This can be reversed with the correct scaling at the NC encoder level.
*)
fGapSize := GVL.astAxes[nIdPositiveAxis].stStatus.fActPosition - GVL.astAxes[nIdNegativeAxis].stStatus.fActPosition;
fGapCentre := (GVL.astAxes[nIdPositiveAxis].stStatus.fActPosition + GVL.astAxes[nIdNegativeAxis].stStatus.fActPosition)/2;

IF ABS(fGapSize) < 100000 THEN
    nGapSizeEncoder := LREAL_TO_UDINT(fGapSize*fEncoderScaling);
END_IF
IF ABS(fGapCentre) < 100000 THEN
    nGapCentreEncoder := LREAL_TO_UDINT(fGapCentre*fEncoderScaling);
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_AllDisabled" Id="{8d0131b7-d925-4748-8e58-1076d969b851}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis;
fVeloSetpointPositiveAxis := 0;
fVeloSetpointNegativeAxis := 0;

fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.ActPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.ActPos)/2;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_Nominal;

actHaltAllAxes();]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_NegativeDisabled" Id="{9ce73458-d767-47d6-a68a-e8346e22f1ca}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.ActPos;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis;
fVeloSetpointPositiveAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo;
fVeloSetpointNegativeAxis := 0;

fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := fGapCentre;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_Nominal;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=50;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_Normal" Id="{2ee67b84-83cd-44fc-84d0-218d8dc38cfa}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis_Nominal;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis_Nominal;
fVeloSetpointPositiveAxis := fVeloSetpointPositiveAxis_Nominal;
fVeloSetpointNegativeAxis := fVeloSetpointNegativeAxis_Nominal;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=100;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_PositiveDisabled" Id="{1b4e9e96-8a89-4887-bc05-9c26a4b38f02}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis;
fPosSetpointNegativeAxis := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.ActPos - GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos;
fVeloSetpointPositiveAxis := 0;
fVeloSetpointNegativeAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo;

fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := fGapCentre;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_Nominal;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=50;]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_SlitPair_ISIS">
      <LineId Id="1461" Count="18" />
      <LineId Id="2162" Count="3" />
      <LineId Id="1480" Count="17" />
      <LineId Id="1683" Count="1" />
      <LineId Id="1682" Count="0" />
      <LineId Id="1498" Count="36" />
      <LineId Id="2065" Count="0" />
      <LineId Id="1535" Count="72" />
      <LineId Id="2167" Count="3" />
      <LineId Id="1610" Count="21" />
      <LineId Id="1637" Count="34" />
      <LineId Id="2066" Count="0" />
      <LineId Id="1672" Count="9" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actCalculateSetpointDirections">
      <LineId Id="3" Count="30" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actCalculateSetpointPositionAndVelocity">
      <LineId Id="727" Count="25" />
      <LineId Id="755" Count="0" />
      <LineId Id="758" Count="0" />
      <LineId Id="761" Count="0" />
      <LineId Id="764" Count="0" />
      <LineId Id="767" Count="0" />
      <LineId Id="770" Count="0" />
      <LineId Id="773" Count="0" />
      <LineId Id="776" Count="0" />
      <LineId Id="778" Count="4" />
      <LineId Id="785" Count="0" />
      <LineId Id="788" Count="0" />
      <LineId Id="791" Count="0" />
      <LineId Id="794" Count="0" />
      <LineId Id="797" Count="0" />
      <LineId Id="799" Count="0" />
      <LineId Id="803" Count="0" />
      <LineId Id="805" Count="0" />
      <LineId Id="808" Count="5" />
      <LineId Id="816" Count="0" />
      <LineId Id="819" Count="0" />
      <LineId Id="822" Count="0" />
      <LineId Id="825" Count="0" />
      <LineId Id="828" Count="0" />
      <LineId Id="831" Count="0" />
      <LineId Id="834" Count="0" />
      <LineId Id="837" Count="0" />
      <LineId Id="839" Count="4" />
      <LineId Id="846" Count="0" />
      <LineId Id="849" Count="0" />
      <LineId Id="852" Count="0" />
      <LineId Id="855" Count="0" />
      <LineId Id="858" Count="0" />
      <LineId Id="861" Count="0" />
      <LineId Id="864" Count="0" />
      <LineId Id="867" Count="0" />
      <LineId Id="869" Count="11" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actGeneratorEnableDisable">
      <LineId Id="2" Count="24" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actHaltAllAxes">
      <LineId Id="6" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="30" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="8" Count="9" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actLimitState">
      <LineId Id="9" Count="0" />
      <LineId Id="1" Count="1" />
      <LineId Id="4" Count="3" />
      <LineId Id="3" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="5" />
      <LineId Id="12" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="34" Count="4" />
      <LineId Id="33" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="29" Count="1" />
      <LineId Id="53" Count="6" />
      <LineId Id="31" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actVirtualAxisEnable">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actVirtualAxisLimits">
      <LineId Id="23" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="14" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="20" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="25" Count="1" />
      <LineId Id="38" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="31" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.actVirtualAxisPositions">
      <LineId Id="3" Count="7" />
      <LineId Id="12" Count="6" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.Setpoint_AllDisabled">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="8" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.Setpoint_NegativeDisabled">
      <LineId Id="2" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.Setpoint_Normal">
      <LineId Id="7" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPair_ISIS.Setpoint_PositiveDisabled">
      <LineId Id="2" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>