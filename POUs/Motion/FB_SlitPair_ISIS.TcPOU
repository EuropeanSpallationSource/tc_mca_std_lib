<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_SlitPairV2_1" Id="{b3c09412-d9b8-4fdb-95f8-f2ca5d9e6945}" SpecialFunc="None">
    <Declaration><![CDATA[
FUNCTION_BLOCK FB_SlitPairV2_1
VAR_INPUT
    nIdPositiveAxis: UINT; //ID of axis for which positive motion increases gap size
    nIdNegativeAxis: UINT; //ID of axis for which negative motion increases gap size
    nIdGapSizeAxis: UINT; //ID of virtual gap aperture size axis
    nIdGapCentreAxis: UINT; //ID of virtual gap centre position axis

    bEnable: BOOL; //Enable slit pair logic functionality
    bReset: BOOL; //Reset from error state
    fEncoderScaling: LREAL := 10000; //Virtual axis scaling denominator, default of 10000
    
    
    
END_VAR

//Linkable objects
VAR
    //Replacement limit links for real axes
    bPositiveAxis_FwdLimit AT %I* : BOOL;
    bPositiveAxis_BwdLimit AT %I* : BOOL;
    bNegativeAxis_FwdLimit AT %I* : BOOL;
    bNegativeAxis_BwdLimit AT %I* : BOOL;
    
    //Software encoders for virtual axes
    nGapSizeEncoder AT %Q*: UDINT := 0;
    nGapCentreEncoder AT %Q*: UDINT := 0;
END_VAR

VAR   
    fGapSize: LREAL;
    fGapCentre: LREAL;
    
    bAllHalted: BOOL := FALSE;
    bInternalResetHome: BOOL :=FALSE;

    fbSetpointGenEnablePositiveAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableNegativeAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableGapSizeAxis: MC_ExtSetPointGenEnable;
    fbSetpointGenEnableGapCentreAxis: MC_ExtSetPointGenEnable;

    fbSetpointGenDisablePositiveAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableNegativeAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableGapSizeAxis: MC_ExtSetPointGenDisable;
    fbSetpointGenDisableGapCentreAxis: MC_ExtSetPointGenDisable;

    fPosSetpointPositiveAxis: LREAL;
    fPosSetpointNegativeAxis: LREAL;
    fPosSetpointGapSizeAxis: LREAL;
    fPosSetpointGapCentreAxis: LREAL;
    
    fPosSetpointPositiveAxis_Nominal: LREAL;
    fPosSetpointNegativeAxis_Nominal: LREAL;
    fPosSetpointGapSizeAxis_Nominal: LREAL;
    fPosSetpointGapCentreAxis_Nominal: LREAL;
    
    fPosSetpointPositiveAxis_New: LREAL;
    fPosSetpointNegativeAxis_New: LREAL;
    fPosSetpointGapSizeAxis_New: LREAL;
    fPosSetpointGapCentreAxis_New: LREAL;

    fVeloSetpointPositiveAxis: LREAL;
    fVeloSetpointNegativeAxis: LREAL;
    fVeloSetpointGapSizeAxis: LREAL;
    fVeloSetpointGapCentreAxis: LREAL;

    fVeloSetpointPositiveAxis_New: LREAL;
    fVeloSetpointNegativeAxis_New: LREAL;
    fVeloSetpointGapSizeAxis_New: LREAL;
    fVeloSetpointGapCentreAxis_New: LREAL;
    
    nDirectionPositiveAxis: DINT;
    nDirectionNegativeAxis: DINT;
    nDirectionGapSizeAxis: DINT;
    nDirectionGapCentreAxis: DINT;
    
    ePositiveAxisState : E_AxisLimitState;
    eNegativeAxisState : E_AxisLimitState;
    eAxisPairState : E_SlitPairLimitState;
    

    eState: E_SlitPairStatesV2 := E_SlitPairStatesV2.eInit;

    bInternalReset: BOOL;
    bHomingReset: BOOL := FALSE;

    //Two resets required due to homing functionality
    bResetInProgressCheck1: BOOL := FALSE;
    bResetInProgressCheck2: BOOL := FALSE;

    //internal MC_Reset, needed because the current reset in FB_Axis works only when there is an error. This should change once the reset functionality changes
    fbInternalResetTrig: R_TRIG;
    fbInternalResetHome: R_TRIG;
    fbResetPositiveAxis: MC_RESET;
    fbResetNegativeAxis: MC_RESET;
    fbResetGapSizeAxis: MC_RESET;
    fbResetGapCentreAxis: MC_RESET;
    fbResetHomedGap: MC_Home;
    fbResetHomedCentre: MC_Home;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Always link limits (can be overridden in later lines)
GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= bPositiveAxis_FwdLimit;
GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= bPositiveAxis_BwdLimit;
GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= bNegativeAxis_FwdLimit;
GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= bNegativeAxis_BwdLimit;


(*SETUP INSTRUCTIONS
Virtual axes:
Encoder type set to Universal
Encoder mask set to 0xFFFFFFFF
Encoder scaling set to match FB
Link nDataIn1 of encoder to FB encoders
Position lag monitoring can be left on*
Dynamics of virtual axes must be configured considering coupled mechanicals (e.g. don't set velocities your real axes can't achieve)
Virtual axis limits will need to be much more state based, for example:
GAP SIZE fwd will only be disabled if +Ve fwd hit AND -ve bwd hit, not OR

NOTES:
DO NOT Enable motion commands to external setpoint generator axis (Halt will get a bit upset and produce errors)
*)

//Position of virtual axes
actVirtualAxisPositions();
//Limit logic
actLimitState_NEW();
actVirtualAxisLimits();

//*NOTES*/
(*
Might need to decouple virtual axis logic (i.e. let gap size increase even if centre position locked)
Will involve untracked movements, will involve NOT enabling certain setpoint generators in certain conditions or even 
disabling and enabling other generators during moves where necessary
i.e. a limit is hit trying to full open the gap size so disabled the centre setpoint generator and "gear it in" to the real axes


*)

//Enable Logic - Virtual axes automatically enable when real axes are enabled
actVirtualAxisEnable();

//Calculate position setpoints
actCalculateSetpointPositions();

//Calculate directions
actCalculateSetpointDirections();

//Error state handling - only handle errors that disable motion
IF bEnable AND (GVL.astAxes[nIdPositiveAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdNegativeAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    //eState := E_SlitPairStatesV2.eError;
END_IF

//Propagate real axis error to virtual
IF GVL.astAxes[nIdPositiveAxis].Axis.Status.ErrorStop AND (NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR NOT GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    //GVL.astAxes[nIdGapSizeAxis].stStatus.bError := TRUE;
    //GVL.astAxes[nIdGapCentreAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.nErrorID := GVL.astAxes[nIdPositiveAxis].stStatus.nErrorID;
    GVL.astAxes[nIdGapCentreAxis].stStatus.nErrorID := GVL.astAxes[nIdPositiveAxis].stStatus.nErrorID;
ELSIF  GVL.astAxes[nIdNegativeAxis].Axis.Status.ErrorStop AND (NOT GVL.astAxes[nIdGapSizeAxis].Axis.Status.ErrorStop OR NOT GVL.astAxes[nIdGapCentreAxis].Axis.Status.ErrorStop) THEN
    //GVL.astAxes[nIdGapSizeAxis].stStatus.bError := TRUE;
    //GVL.astAxes[nIdGapCentreAxis].stStatus.bError := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.nErrorID := GVL.astAxes[nIdNegativeAxis].stStatus.nErrorID;
    GVL.astAxes[nIdGapCentreAxis].stStatus.nErrorID := GVL.astAxes[nIdNegativeAxis].stStatus.nErrorID;
END_IF

//Internal Reset linked to any axis reset
bInternalReset := bReset OR GVL.astAxes[nIdPositiveAxis].stControl.bReset OR GVL.astAxes[nIdNegativeAxis].stControl.bReset OR GVL.astAxes[nIdGapSizeAxis].stControl.bReset OR GVL.astAxes[nIdGapCentreAxis].stControl.bReset;

//If real axis is homing, change state
IF bEnable AND (GVL.astAxes[nIdPositiveAxis].Axis.Status.HomingBusy OR GVL.astAxes[nIdNegativeAxis].Axis.Status.HomingBusy) THEN
    eState := E_SlitPairStatesV2.eWaitForRealHomed;
END_IF

//Link all halt buttons in motors
IF GVL.astAxes[nIdPositiveAxis].stControl.bHalt OR GVL.astAxes[nIdNegativeAxis].stControl.bHalt OR
    GVL.astAxes[nIdGapSizeAxis].stControl.bHalt OR GVL.astAxes[nIdGapCentreAxis].stControl.bHalt THEN
    actHaltAllAxes();
END_IF

//Propagate homing status
fbResetHomedGap(Axis:= GVL.astAxes[nIdGapSizeAxis].Axis, HomingMode:= MC_ResetCalibration);
fbResetHomedCentre(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis, HomingMode:= MC_ResetCalibration);
fbInternalResetHome(CLK:= fbResetHomedCentre.Done OR fbResetHomedGap.Done );
IF NOT GVL.astAxes[nIdPositiveAxis].stStatus.bHomed OR NOT GVL.astAxes[nIdNegativeAxis].stStatus.bHomed THEN
        fbResetHomedGap.Execute := TRUE;
        fbResetHomedCentre.Execute := TRUE;
END_IF

IF fbInternalResetHome.Q THEN
        fbResetHomedGap.Execute := FALSE;
        fbResetHomedCentre.Execute := FALSE;
END_IF


//State machine
IF bEnable THEN
    CASE eState OF  //HOMING LOOP ISSUE
        E_SlitPairStatesV2.eInit:
            //If real axes are calibrated, then home the virtual axes, else go Operatioanl
            fbResetPositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis, Execute:=FALSE);
            fbResetNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis, Execute:=FALSE);
            fbResetGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis, Execute:=FALSE);
            fbResetGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis, Execute:=FALSE);
            IF GVL.astAxes[nIdPositiveAxis].stStatus.bHomed AND GVL.astAxes[nIdNegativeAxis].stStatus.bHomed THEN
               GVL.astAxes[nIdGapSizeAxis].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
               GVL.astAxes[nIdGapCentreAxis].stConfig.eHomeSeq := E_HomingRoutines.eHomeDirect;
               GVL.astAxes[nIdGapSizeAxis].stConfig.fHomePosition := fGapSize;
               GVL.astAxes[nIdGapCentreAxis].stConfig.fHomePosition := fGapCentre;
                eState := E_SlitPairStatesV2.eWaitForVirtualHomed;
            ELSE
                eState := E_SlitPairStatesV2.eOperational;
            END_IF

        E_SlitPairStatesV2.eWaitForVirtualHomed:
            //Wait for virtual axis homing to complete/
            GVL.astAxes[nIdGapSizeAxis].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[nIdGapSizeAxis].stControl.bExecute := TRUE;
            GVL.astAxes[nIdGapCentreAxis].stControl.eCommand := E_MotionFunctions.eHome;
            GVL.astAxes[nIdGapCentreAxis].stControl.bExecute := TRUE;
            IF GVL.astAxes[nIdGapSizeAxis].stStatus.bHomed AND GVL.astAxes[nIdGapCentreAxis].stStatus.bHomed THEN
                eState := E_SlitPairStatesV2.eOperational;
            END_IF
            //IF NOT IN HOMING STATE

        E_SlitPairStatesV2.eOperational:
            bResetInProgressCheck1 := FALSE;
            //Detect whether real or virtual axes are moving
            IF GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving OR GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving THEN
                eState := E_SlitPairStatesV2.eEnableRealGenerators;
            END_IF
            IF GVL.astAxes[nIdPositiveAxis].stStatus.bMoving OR GVL.astAxes[nIdNegativeAxis].stStatus.bMoving THEN
                eState := E_SlitPairStatesV2.eEnableVirtualGenerators;
            END_IF

        E_SlitPairStatesV2.eEnableRealGenerators:
            //Temporary override of limits
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= TRUE;
            fbSetpointGenEnablePositiveAxis.Execute := TRUE;
            fbSetpointGenEnableNegativeAxis.Execute := TRUE;
            eState := E_SlitPairStatesV2.eCheckRealAxisGeneratorsEnabled;

        E_SlitPairStatesV2.eCheckRealAxisGeneratorsEnabled:
            //Hold MC_Power on until generators have enabled           
            IF fbSetpointGenEnablePositiveAxis.Enabled AND fbSetpointGenEnableNegativeAxis.Enabled THEN
                eState := E_SlitPairStatesV2.eWaitForVirtualMoveDone;
            END_IF

        E_SlitPairStatesV2.eWaitForVirtualMoveDone:            
            IF NOT(GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving OR GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving) THEN
                eState := E_SlitPairStatesV2.eDisableRealGenerators;
            END_IF

        E_SlitPairStatesV2.eDisableRealGenerators:
            fbSetpointGenDisablePositiveAxis.Execute := TRUE;
            fbSetpointGenDisableNegativeAxis.Execute := TRUE;
            eState := E_SlitPairStatesV2.eOperational;

        E_SlitPairStatesV2.eEnableVirtualGenerators:
            //Hold MC_Power on until generators have enabled
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd:= TRUE;
            GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd:= TRUE;
            fbSetpointGenEnableGapSizeAxis.Execute := TRUE;
            fbSetpointGenEnableGapCentreAxis.Execute := TRUE;
            eState := E_SlitPairStatesV2.eCheckVirtualAxisGeneratorsEnabled;

        E_SlitPairStatesV2.eCheckVirtualAxisGeneratorsEnabled:
            //Hold MC_Power on until generators have enabled
            IF fbSetpointGenEnableGapSizeAxis.Enabled AND fbSetpointGenEnableGapCentreAxis.Enabled THEN
                eState := E_SlitPairStatesV2.eWaitForRealMoveDone;
            END_IF

        E_SlitPairStatesV2.eWaitForRealMoveDone:
            IF NOT(GVL.astAxes[nIdPositiveAxis].stStatus.bMoving OR GVL.astAxes[nIdNegativeAxis].stStatus.bMoving) THEN
                eState := E_SlitPairStatesV2.eDisableVirtualGenerators;
            END_IF

        E_SlitPairStatesV2.eDisableVirtualGenerators:
            fbSetpointGenDisableGapSizeAxis.Execute := TRUE;
            fbSetpointGenDisableGapCentreAxis.Execute := TRUE;
            eState := E_SlitPairStatesV2.eOperational;

        E_SlitPairStatesV2.eError:
            actHaltAllAxes();

            IF bHomingReset THEN
                bInternalReset := TRUE;
                bResetInProgressCheck1 := TRUE;
                bResetInProgressCheck2 := TRUE;
                bHomingReset := FALSE;
            END_IF
            IF bInternalReset OR bReset OR bResetInProgressCheck2 THEN
                fbResetPositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis, Execute:=TRUE);
                fbResetNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis, Execute:=TRUE);
                fbResetGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis, Execute:=TRUE);
                fbResetGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis, Execute:=TRUE);
                GVL.astAxes[nIdPositiveAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdNegativeAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdGapSizeAxis].stControl.bReset := TRUE;
                GVL.astAxes[nIdGapCentreAxis].stControl.bReset := TRUE;
                IF NOT(bResetInProgressCheck1) THEN
                    bResetInProgressCheck2 := FALSE;
                END_IF
            END_IF

            IF NOT(GVL.astAxes[nIdPositiveAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdNegativeAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdGapSizeAxis].stStatus.bError) AND NOT(GVL.astAxes[nIdGapCentreAxis].stStatus.bError) THEN
                eState := E_SlitPairStatesV2.eInit;
            END_IF

        E_SlitPairStatesV2.eWaitForRealHomed:
            bHomingReset := TRUE;
            IF NOT GVL.astAxes[nIdPositiveAxis].Axis.Status.Homed OR NOT GVL.astAxes[nIdNegativeAxis].Axis.Status.Homed THEN
                eState := E_SlitPairStatesV2.eInit;
            END_IF
    END_CASE
END_IF
//Call spGenerator FBs
actGeneratorEnableDisable();

//Feed externalsetpoint generators setpoint values - ignoring acceleration
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdPositiveAxis].Axis, Position:= fPosSetpointPositiveAxis, Velocity:= fVeloSetpointPositiveAxis, Acceleration:= 0, Direction:= nDirectionPositiveAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdNegativeAxis].Axis, Position:= fPosSetpointNegativeAxis, Velocity:= fVeloSetpointNegativeAxis, Acceleration:= 0, Direction:= nDirectionNegativeAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdGapSizeAxis].Axis, Position:= fPosSetpointGapSizeAxis, Velocity:= fVeloSetpointGapSizeAxis, Acceleration:= 0, Direction:= nDirectionGapSizeAxis);
MC_ExtSetPointGenFeed(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis, Position:= fPosSetpointGapCentreAxis, Velocity:= fVeloSetpointGapCentreAxis, Acceleration:= 0, Direction:= nDirectionGapCentreAxis);

bReset := FALSE;
]]></ST>
    </Implementation>
    <Folder Name="Setpoint_Generator_Actions" Id="{8e494922-e7c2-4daa-80b3-ea89aa78df74}" />
    <Action Name="actCalculateSetpointDirections" Id="{5abf4283-d432-4b19-be96-a15b54858b40}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[
IF fVeloSetpointPositiveAxis > 0 THEN
    nDirectionPositiveAxis := 1; //moving forward
ELSIF fVeloSetpointPositiveAxis < 0 THEN
    nDirectionPositiveAxis := -1; //moving backward
ELSE
    nDirectionPositiveAxis := 0; //stationary
END_IF

IF fVeloSetpointNegativeAxis > 0 THEN
    nDirectionNegativeAxis := 1; //moving forward
ELSIF fVeloSetpointNegativeAxis < 0 THEN
    nDirectionNegativeAxis := -1; //moving backward
ELSE
    nDirectionNegativeAxis := 0; //stationary
END_IF

IF fVeloSetpointGapSizeAxis > 0 THEN
    nDirectionGapSizeAxis := 1; //moving forward
ELSIF fVeloSetpointGapSizeAxis < 0 THEN
    nDirectionGapSizeAxis := -1; //moving backward
ELSE
    nDirectionGapSizeAxis := 0; //stationary
END_IF

IF fVeloSetpointGapCentreAxis > 0 THEN
    nDirectionGapCentreAxis := 1; //moving forward
ELSIF fVeloSetpointGapCentreAxis < 0 THEN
    nDirectionGapCentreAxis := -1; //moving backward
ELSE
    nDirectionGapCentreAxis := 0; //stationary
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actCalculateSetpointPositions" Id="{1756795d-6a25-4bcd-9ca1-dcd9ccd9b4a7}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[//Axis status update to get current NC move progress
GVL.astAxes[nIdPositiveAxis].Axis.ReadStatus();
GVL.astAxes[nIdNegativeAxis].Axis.ReadStatus();
GVL.astAxes[nIdGapSizeAxis].Axis.ReadStatus();
GVL.astAxes[nIdGapCentreAxis].Axis.ReadStatus();


//Generate the default setpoint positions assuming no limits
fPosSetpointPositiveAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetPos + (GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos/2);
fPosSetpointNegativeAxis_Nominal := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetPos - (GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos/2);
fPosSetpointGapSizeAxis_Nominal := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos;
fPosSetpointGapCentreAxis_Nominal := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos) / 2;

//Generate default setpoint velocities assuming no limits
fVeloSetpointPositiveAxis_New := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetVelo +(GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo/2);
fVeloSetpointNegativeAxis_New := GVL.astAxes[nIdGapCentreAxis].Axis.NcToPlc.SetVelo -(GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo/2);
fVeloSetpointGapSizeAxis_New := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetVelo - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetVelo;
fVeloSetpointGapCentreAxis_New := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetVelo + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetVelo;


//IF MOVING IN VIRTUAL SLIT CONTROL MODE
IF GVL.astAxes[nIdPositiveAxis].Axis.Status.ExtSetPointGenEnabled OR GVL.astAxes[nIdNegativeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    //IF GAP SIZE GETTING BIGGER
    IF GVL.astAxes[nIdGapSizeAxis].Axis.Status.PositiveDirection THEN
        CASE eAxisPairState OF            
        E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:
            Setpoint_PositiveDisabled();
            
        E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:
            Setpoint_AllDisabled();
            
        E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:
            Setpoint_PositiveDisabled();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward:
            Setpoint_NegativeDisabled();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:
            Setpoint_NegativeDisabled();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:
            Setpoint_Normal();
        END_CASE
    //IF GAP SIZE GETTING SMALLER
    ELSIF GVL.astAxes[nIdGapSizeAxis].Axis.Status.NegativeDirection THEN
        CASE eAxisPairState OF            
        E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:
            Setpoint_NegativeDisabled();

        E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:
            Setpoint_AllDisabled();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward:
            Setpoint_PositiveDisabled();
            
        E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:
            Setpoint_PositiveDisabled();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:
            Setpoint_NegativeDisabled();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:
            Setpoint_Normal();
            
        E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:
            Setpoint_Normal();                       
        END_CASE
    ELSE
        //GAP CENTRE MOVING FORWARD
        IF GVL.astAxes[nIdGapCentreAxis].Axis.Status.PositiveDirection THEN
            CASE eAxisPairState OF            
            E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:
                Setpoint_AllDisabled();

            E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward:
                Setpoint_Normal();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:
                Setpoint_Normal();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:
                Setpoint_Normal();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:
                Setpoint_Normal();                       
            END_CASE
        //GAP CENTRE MOVING BACKWARD
        ELSIF GVL.astAxes[nIdGapCentreAxis].Axis.Status.NegativeDirection THEN
            CASE eAxisPairState OF            
            E_SlitPairLimitState.PositiveOnForward_NegativeOnForward:
                Setpoint_Normal();

            E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit:
                Setpoint_Normal();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward:
                Setpoint_Normal();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward:
                Setpoint_AllDisabled();
            
            E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit:
                Setpoint_Normal();                       
            END_CASE
		END_IF
    END_IF
END_IF

//IF MOVING WITH REAL BLADES IN CONTROL - NORMAL OPERATION AS NO LIMITS ON VIRTUALS
IF GVL.astAxes[nIdGapCentreAxis].Axis.Status.ExtSetPointGenEnabled AND GVL.astAxes[nIdGapSizeAxis].Axis.Status.ExtSetPointGenEnabled THEN
    fPosSetpointGapSizeAxis := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos - GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos;
    fPosSetpointGapCentreAxis := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.SetPos) / 2;
    fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_New;
    fVeloSetpointGapSizeAxis := fVeloSetpointGapSizeAxis_New;
END_IF


]]></ST>
      </Implementation>
    </Action>
    <Action Name="actGeneratorEnableDisable" Id="{3488c74c-bc18-48be-a44b-85fc45e9d726}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[
fbSetpointGenEnablePositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis);
fbSetpointGenEnablePositiveAxis.Execute := FALSE;

fbSetpointGenEnableNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis);
fbSetpointGenEnableNegativeAxis.Execute := FALSE;

fbSetpointGenEnableGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis);
fbSetpointGenEnableGapSizeAxis.Execute := FALSE;

fbSetpointGenEnableGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis);
fbSetpointGenEnableGapCentreAxis.Execute := FALSE;


fbSetpointGenDisablePositiveAxis(Axis:=GVL.astAxes[nIdPositiveAxis].Axis);
fbSetpointGenDisablePositiveAxis.Execute := FALSE;

fbSetpointGenDisableNegativeAxis(Axis:=GVL.astAxes[nIdNegativeAxis].Axis);
fbSetpointGenDisableNegativeAxis.Execute := FALSE;

fbSetpointGenDisableGapSizeAxis(Axis:=GVL.astAxes[nIdGapSizeAxis].Axis);
fbSetpointGenDisableGapSizeAxis.Execute := FALSE;

fbSetpointGenDisableGapCentreAxis(Axis:=GVL.astAxes[nIdGapCentreAxis].Axis);
fbSetpointGenDisableGapCentreAxis.Execute := FALSE;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHaltAllAxes" Id="{b7970e1d-c1fa-487e-a0a7-5d7f0550df46}">
      <Implementation>
        <ST><![CDATA[
GVL.astAxes[nIdPositiveAxis].stControl.bHalt := TRUE;
GVL.astAxes[nIdNegativeAxis].stControl.bHalt := TRUE;
GVL.astAxes[nIdGapSizeAxis].stControl.bHalt := TRUE;
GVL.astAxes[nIdGapCentreAxis].stControl.bHalt := TRUE;
bAllHalted := TRUE;

//Reset Halts
IF bAllHalted AND NOT GVL.astAxes[nIdPositiveAxis].stStatus.bMoving AND NOT GVL.astAxes[nIdNegativeAxis].stStatus.bMoving
 AND NOT GVL.astAxes[nIdGapSizeAxis].stStatus.bMoving AND NOT GVL.astAxes[nIdGapCentreAxis].stStatus.bMoving THEN
   GVL.astAxes[nIdPositiveAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdNegativeAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdGapSizeAxis].stControl.bHalt := FALSE;
   GVL.astAxes[nIdGapCentreAxis].stControl.bHalt := FALSE;
   bAllHalted := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actLimitState" Id="{76476edf-1ca7-4d8b-8b71-a3d45cf78601}">
      <Implementation>
        <ST><![CDATA[//Positive axis state
IF GVL.astAxes[nIdPositiveAxis].stInputs.bLimitFwd = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF GVL.astAxes[nIdPositiveAxis].stInputs.bLimitBwd = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    ePositiveAxisState := E_AxisLimitState.NoLimit;
END_IF

//Negative axis state
IF GVL.astAxes[nIdNegativeAxis].stInputs.bLimitFwd = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF GVL.astAxes[nIdNegativeAxis].stInputs.bLimitBwd = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    eNegativeAxisState := E_AxisLimitState.NoLimit;
END_IF



CASE ePositiveAxisState OF
    E_AxisLimitState.OnForwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit;            
		END_CASE
    E_AxisLimitState.OnBackwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit;            
		END_CASE
    E_AxisLimitState.NoLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit;            
		END_CASE
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actLimitState_NEW" Id="{0bf1ea49-b548-4e60-a8eb-6a1e52eb2a32}">
      <Implementation>
        <ST><![CDATA[//Positive axis state
IF bPositiveAxis_FwdLimit = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF bPositiveAxis_BwdLimit = FALSE THEN
    ePositiveAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    ePositiveAxisState := E_AxisLimitState.NoLimit;
END_IF

//Negative axis state
IF bNegativeAxis_FwdLimit = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnForwardLimit;
ELSIF bNegativeAxis_BwdLimit = FALSE THEN
    eNegativeAxisState := E_AxisLimitState.OnBackwardLimit;
ELSE
    eNegativeAxisState := E_AxisLimitState.NoLimit;
END_IF



CASE ePositiveAxisState OF
    E_AxisLimitState.OnForwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnForward_NegativeOnNoLimit;            
		END_CASE
    E_AxisLimitState.OnBackwardLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnBackward_NegativeOnNoLimit;            
		END_CASE
    E_AxisLimitState.NoLimit:
        CASE eNegativeAxisState OF
            E_AxisLimitState.OnForwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnForward;
            E_AxisLimitState.OnBackwardLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnBackward;
            E_AxisLimitState.NoLimit:
                eAxisPairState := E_SlitPairLimitState.PositiveOnNoLimit_NegativeOnNoLimit;            
		END_CASE
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisEnable" Id="{9800ad84-33b1-45e1-8f1c-18ce4e663f2f}">
      <Implementation>
        <ST><![CDATA[GVL.astAxes[nIdGapSizeAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stControl.bEnable AND GVL.astAxes[nIdNegativeAxis].stControl.bEnable;
GVL.astAxes[nIdGapCentreAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stControl.bEnable AND GVL.astAxes[nIdNegativeAxis].stControl.bEnable;

//GVL.astAxes[nIdGapSizeAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stStatus.bEnabled AND GVL.astAxes[nIdNegativeAxis].stStatus.bEnabled;
//GVL.astAxes[nIdGapCentreAxis].stControl.bEnable := GVL.astAxes[nIdPositiveAxis].stStatus.bEnabled AND GVL.astAxes[nIdNegativeAxis].stStatus.bEnabled;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisLimits" Id="{b46f168f-6065-4588-af1f-8e4bf3d9b991}">
      <Implementation>
        <ST><![CDATA[//GAP SIZE FORWARD LIMIT
IF GVL.astAxes[nIdPositiveAxis].stStatus.bFwEnabled = FALSE AND GVL.astAxes[nIdNegativeAxis].stStatus.bBwEnabled = FALSE THEN
    //GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitFwd := FALSE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.bFwEnabled := FALSE;
ELSE
    //GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitFwd := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.bFwEnabled := TRUE;
END_IF

//GAP SIZE BACKWARD LIMIT
IF GVL.astAxes[nIdPositiveAxis].stStatus.bBwEnabled = FALSE AND GVL.astAxes[nIdNegativeAxis].stStatus.bFwEnabled = FALSE THEN
    //GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitBwd := FALSE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.bBwEnabled := FALSE;
ELSE
    //GVL.astAxes[nIdGapSizeAxis].stInputs.bLimitBwd := TRUE;
    GVL.astAxes[nIdGapSizeAxis].stStatus.bBwEnabled := TRUE;
END_IF

//GAP CENTRE FORWARD LIMIT
IF GVL.astAxes[nIdPositiveAxis].stStatus.bFwEnabled = FALSE OR GVL.astAxes[nIdNegativeAxis].stStatus.bFwEnabled = FALSE THEN
    //GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitFwd := FALSE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bFwEnabled := FALSE;
ELSE
    //GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitFwd := TRUE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bFwEnabled := TRUE;
END_IF

//GAP CENTRE BACKWARD LIMIT
IF GVL.astAxes[nIdPositiveAxis].stStatus.bBwEnabled = FALSE OR GVL.astAxes[nIdNegativeAxis].stStatus.bBwEnabled = FALSE THEN
    //GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitBwd := FALSE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bBwEnabled := FALSE;
ELSE
    //GVL.astAxes[nIdGapCentreAxis].stInputs.bLimitBwd := TRUE;
    GVL.astAxes[nIdGapCentreAxis].stStatus.bBwEnabled := TRUE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="actVirtualAxisPositions" Id="{728f3665-a1f5-47e1-9096-f32eff42a946}">
      <Implementation>
        <ST><![CDATA[
(*Calculate virtual axis positions and convert to UDINT.
Conversion to UDINT is prohibited if it would exceed UDINT max value of 4,294,967,295.
If this is not done, it can cause overflow when connected to the encoder input and hard-crash the PLC which will only recover with a power cycle.
To preserve decimal position data of the LREAL (i.e. anything <1mm) it is necessary to scale the value before converting to UDINT.
This can be reversed with the correct scaling at the NC encoder level.
*)
fGapSize := GVL.astAxes[nIdPositiveAxis].stStatus.fActPosition - GVL.astAxes[nIdNegativeAxis].stStatus.fActPosition;
fGapCentre := (GVL.astAxes[nIdPositiveAxis].stStatus.fActPosition + GVL.astAxes[nIdNegativeAxis].stStatus.fActPosition)/2;


    IF ABS(fGapSize) < 100000 THEN
        nGapSizeEncoder := LREAL_TO_UDINT(fGapSize*fEncoderScaling);
    END_IF
    IF ABS(fGapCentre) < 100000 THEN
        nGapCentreEncoder := LREAL_TO_UDINT(fGapCentre*fEncoderScaling);
    END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_AllDisabled" Id="{8d0131b7-d925-4748-8e58-1076d969b851}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis;            
fVeloSetpointPositiveAxis := 0;
fVeloSetpointNegativeAxis := 0;

fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := (GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.ActPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.ActPos)/2;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_New;


actHaltAllAxes();]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_NegativeDisabled" Id="{9ce73458-d767-47d6-a68a-e8346e22f1ca}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos + GVL.astAxes[nIdNegativeAxis].Axis.NcToPlc.ActPos;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis;
fVeloSetpointPositiveAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo;
fVeloSetpointNegativeAxis := 0;
            
fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := fGapCentre;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_New;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=50;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_Normal" Id="{2ee67b84-83cd-44fc-84d0-218d8dc38cfa}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis_Nominal;
fPosSetpointNegativeAxis := fPosSetpointNegativeAxis_Nominal;
fVeloSetpointPositiveAxis := fVeloSetpointPositiveAxis_New;
fVeloSetpointNegativeAxis := fVeloSetpointNegativeAxis_New;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=100;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Setpoint_PositiveDisabled" Id="{1b4e9e96-8a89-4887-bc05-9c26a4b38f02}" FolderPath="Setpoint_Generator_Actions\">
      <Implementation>
        <ST><![CDATA[fPosSetpointPositiveAxis := fPosSetpointPositiveAxis;
fPosSetpointNegativeAxis := GVL.astAxes[nIdPositiveAxis].Axis.NcToPlc.ActPos - GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetPos;
fVeloSetpointPositiveAxis := 0;
fVeloSetpointNegativeAxis := GVL.astAxes[nIdGapSizeAxis].Axis.NcToPlc.SetVelo;
            
fbSetpointGenEnableGapCentreAxis.Execute:= TRUE;
fbSetpointGenEnableGapCentreAxis(Axis:= GVL.astAxes[nIdGapCentreAxis].Axis);
fPosSetpointGapCentreAxis := fGapCentre;
fVeloSetpointGapCentreAxis := fVeloSetpointGapCentreAxis_New;

GVL.astAxes[nIdGapSizeAxis].stConfig.fOverride:=50;]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_SlitPairV2_1">
      <LineId Id="789" Count="0" />
      <LineId Id="791" Count="0" />
      <LineId Id="793" Count="2" />
      <LineId Id="792" Count="0" />
      <LineId Id="790" Count="0" />
      <LineId Id="461" Count="9" />
      <LineId Id="904" Count="0" />
      <LineId Id="903" Count="0" />
      <LineId Id="905" Count="0" />
      <LineId Id="471" Count="19" />
      <LineId Id="492" Count="2" />
      <LineId Id="496" Count="92" />
      <LineId Id="796" Count="2" />
      <LineId Id="591" Count="0" />
      <LineId Id="799" Count="1" />
      <LineId Id="593" Count="3" />
      <LineId Id="599" Count="4" />
      <LineId Id="606" Count="10" />
      <LineId Id="802" Count="2" />
      <LineId Id="801" Count="0" />
      <LineId Id="619" Count="5" />
      <LineId Id="627" Count="47" />
      <LineId Id="805" Count="0" />
      <LineId Id="675" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actCalculateSetpointDirections">
      <LineId Id="2" Count="31" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actCalculateSetpointPositions">
      <LineId Id="706" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="144" Count="1" />
      <LineId Id="104" Count="1" />
      <LineId Id="167" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="705" Count="0" />
      <LineId Id="268" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="709" Count="3" />
      <LineId Id="708" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="721" Count="0" />
      <LineId Id="312" Count="0" />
      <LineId Id="456" Count="0" />
      <LineId Id="525" Count="0" />
      <LineId Id="468" Count="0" />
      <LineId Id="724" Count="0" />
      <LineId Id="470" Count="0" />
      <LineId Id="474" Count="0" />
      <LineId Id="534" Count="0" />
      <LineId Id="536" Count="0" />
      <LineId Id="535" Count="0" />
      <LineId Id="486" Count="1" />
      <LineId Id="491" Count="0" />
      <LineId Id="568" Count="11" />
      <LineId Id="545" Count="0" />
      <LineId Id="547" Count="0" />
      <LineId Id="546" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="722" Count="0" />
      <LineId Id="580" Count="0" />
      <LineId Id="582" Count="1" />
      <LineId Id="609" Count="0" />
      <LineId Id="585" Count="1" />
      <LineId Id="610" Count="0" />
      <LineId Id="588" Count="1" />
      <LineId Id="611" Count="0" />
      <LineId Id="591" Count="1" />
      <LineId Id="612" Count="0" />
      <LineId Id="594" Count="1" />
      <LineId Id="613" Count="0" />
      <LineId Id="597" Count="1" />
      <LineId Id="614" Count="0" />
      <LineId Id="600" Count="1" />
      <LineId Id="615" Count="0" />
      <LineId Id="603" Count="1" />
      <LineId Id="616" Count="0" />
      <LineId Id="606" Count="2" />
      <LineId Id="581" Count="0" />
      <LineId Id="617" Count="2" />
      <LineId Id="649" Count="26" />
      <LineId Id="620" Count="0" />
      <LineId Id="723" Count="0" />
      <LineId Id="676" Count="0" />
      <LineId Id="678" Count="26" />
      <LineId Id="677" Count="0" />
      <LineId Id="621" Count="0" />
      <LineId Id="714" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="726" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="308" Count="0" />
      <LineId Id="307" Count="0" />
      <LineId Id="309" Count="1" />
      <LineId Id="196" Count="0" />
      <LineId Id="363" Count="1" />
      <LineId Id="354" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actGeneratorEnableDisable">
      <LineId Id="2" Count="24" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actHaltAllAxes">
      <LineId Id="2" Count="15" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actLimitState">
      <LineId Id="9" Count="0" />
      <LineId Id="1" Count="1" />
      <LineId Id="4" Count="3" />
      <LineId Id="3" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="5" />
      <LineId Id="12" Count="0" />
      <LineId Id="20" Count="2" />
      <LineId Id="19" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="34" Count="4" />
      <LineId Id="33" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="29" Count="1" />
      <LineId Id="53" Count="6" />
      <LineId Id="31" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actLimitState_NEW">
      <LineId Id="9" Count="0" />
      <LineId Id="1" Count="1" />
      <LineId Id="4" Count="3" />
      <LineId Id="3" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="13" Count="5" />
      <LineId Id="12" Count="0" />
      <LineId Id="20" Count="2" />
      <LineId Id="19" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="34" Count="4" />
      <LineId Id="33" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="29" Count="1" />
      <LineId Id="53" Count="6" />
      <LineId Id="31" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actVirtualAxisEnable">
      <LineId Id="5" Count="1" />
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actVirtualAxisLimits">
      <LineId Id="23" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="21" Count="1" />
      <LineId Id="9" Count="0" />
      <LineId Id="25" Count="2" />
      <LineId Id="38" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="39" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="32" Count="2" />
      <LineId Id="40" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="31" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.actVirtualAxisPositions">
      <LineId Id="2" Count="16" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.Setpoint_AllDisabled">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="8" Count="1" />
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.Setpoint_NegativeDisabled">
      <LineId Id="2" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.Setpoint_Normal">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_SlitPairV2_1.Setpoint_PositiveDisabled">
      <LineId Id="2" Count="7" />
      <LineId Id="1" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>