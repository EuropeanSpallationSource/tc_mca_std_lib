<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Axis" Id="{45901cd0-c6d2-4114-b7cf-de832171219f}" SpecialFunc="None">
    <Declaration><![CDATA[//Function block to run a virtual drive with Nc
FUNCTION_BLOCK FB_Axis
VAR
    sVersion: STRING := '1.0.4';
END_VAR

VAR CONSTANT
    nMULTI_MASTER_MAX_AXES: UINT := 4;
    //Kept static as numerator is LREAL and consistent with multigearing
    nRATIO_DENOMINATOR_DEFAULT: UINT := 1;
    //By default 0 as represents no existing gearing
    nNO_GEARING: UINT := 0;
END_VAR

VAR_IN_OUT
    stAxisStruct: ST_AxisStruct;
END_VAR

VAR
    iAxisIndex: UINT;
    iMultiMastersAxesIndex: UINT;
    iSlaveAxesIndex: UINT;

    stMasterAxis: ST_GearAxis := (nIndex := 1, fRatio := 0);
    fbReset: MC_Reset;
    fbPower: MC_Power;
    fbStop: MC_Stop;
    fbHalt: MC_Halt;
    fbJog: MC_Jog;
    fbMoveAbsolute: MC_MoveAbsolute;
    fbMoveVelocity: MC_MoveVelocity;
    fbMoveRelative: MC_MoveRelative;
    fbMoveModulo: MC_MoveModulo;
    fbGearIn: MC_GearIn;
    fbGearOut: MC_GearOut;
    fbGearInMultiMaster: MC_GearInMultiMaster;
    fbHome: FB_Homing;
    fbExecuteRiseEdge: R_TRIG;
    fbJogRiseEdge: R_TRIG;
    fbStopRiseEdge: R_TRIG;
    fbResetRiseEdge: R_TRIG;
    fbStopFinishedRiseEdge: R_TRIG;
    fbResetFinishedRiseEdge: R_TRIG;
    fbCommandAbortedRiseEdge: R_TRIG;
    fbDoneRiseEdge: R_TRIG;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[stAxisStruct.Axis.ReadStatus();

//Call of all MC Instances and set all Executes to FALSE
fbPower(Axis := stAxisStruct.Axis);
fbPower.Enable := FALSE;

fbReset(Axis := stAxisStruct.Axis);
fbReset.Execute := FALSE;

fbStop(Axis := stAxisStruct.Axis);
fbStop.Execute := FALSE;

fbHalt(Axis := stAxisStruct.Axis);
fbHalt.Execute := FALSE;

fbJog(Axis := stAxisStruct.Axis);

fbHome(Axis := stAxisStruct.Axis);
fbHome.bExecute := FALSE;

fbMoveAbsolute(Axis := stAxisStruct.Axis);
fbMoveAbsolute.Execute := FALSE;

fbMoveRelative(Axis := stAxisStruct.Axis);
fbMoveRelative.Execute := FALSE;

fbMoveVelocity(Axis := stAxisStruct.Axis);
fbMoveVelocity.Execute := FALSE;

fbMoveModulo(Axis := stAxisStruct.Axis);
fbMoveModulo.Execute := FALSE;

fbGearin(Slave := stAxisStruct.Axis, Master := GVL.astAxes[stMasterAxis.nIndex].Axis);
fbGearIn.Execute := FALSE;

fbGearInMultiMaster(Slave := stAxisStruct.Axis,
    Master1 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex].Axis,
    Master2 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex].Axis,
    Master3 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex].Axis,
    Master4 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex].Axis);

fbGearOut(Slave := stAxisStruct.Axis);
fbGearOut.Execute := FALSE;

//Linking the limit swtiches
stAxisStruct.stStatus.bFwEnabled := stAxisStruct.stInputs.bLimitFwd;
stAxisStruct.stStatus.bBwEnabled := stAxisStruct.stInputs.bLimitBwd;

FOR iAxisIndex := 1 TO GVL_APP.nAXIS_NUM DO
    IF (stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] <> 0) THEN
        stAxisStruct.stStatus.bFwEnabled := stAxisStruct.stStatus.bFwEnabled AND SEL(stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] > 0, GVL.astAxes[iAxisIndex].stStatus.bBwEnabled, GVL.astAxes[iAxisIndex].stStatus.bFwEnabled);
        stAxisStruct.stStatus.bBwEnabled := stAxisStruct.stStatus.bBwEnabled AND SEL(stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] > 0, GVL.astAxes[iAxisIndex].stStatus.bFwEnabled, GVL.astAxes[iAxisIndex].stStatus.bBwEnabled);
    END_IF
END_FOR

//Power
fbPower.Enable := stAxisStruct.stControl.bEnable;
fbPower.Enable_Positive := stAxisStruct.stStatus.bFwEnabled;
fbPower.Enable_Negative := stAxisStruct.stStatus.bBwEnabled;
fbPower.Override := stAxisStruct.stConfig.fOverride;
stAxisStruct.stStatus.bEnabled := fbPower.Status;

//Stop
fbStop.Execute := stAxisStruct.stControl.bStop;
fbStop.Deceleration := stAxisStruct.stConfig.fDeceleration;

//Reset only if axis is in error state
IF stAxisStruct.stStatus.bError THEN 
    fbReset.Execute := stAxisStruct.stControl.bReset; 
ELSE
    stAxisStruct.stControl.bReset := FALSE;
END_IF

//Motion Functions
CASE stAxisStruct.stControl.eCommand OF
    E_MotionFunctions.eMoveAbsolute:
        fbMoveAbsolute.Execute := stAxisStruct.stControl.bExecute;
        fbMoveAbsolute.Position := stAxisStruct.stConfig.fPosition;
        fbMoveAbsolute.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveAbsolute.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveAbsolute.Deceleration := stAxisStruct.stConfig.fDeceleration;

    E_MotionFunctions.eMoveRelative:
        fbMoveRelative.Execute := stAxisStruct.stControl.bExecute;
        fbMoveRelative.Distance := stAxisStruct.stConfig.fPosition;
        fbMoveRelative.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveRelative.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveRelative.Deceleration := stAxisStruct.stConfig.fDeceleration;

    E_MotionFunctions.eJog:
        fbJog.JogForward := stAxisStruct.stControl.bJogFwd AND NOT (stAxisStruct.stControl.bExecute OR stAxisStruct.stStatus.bError);
        fbJog.JogBackwards := stAxisStruct.stControl.bJogBwd AND NOT (stAxisStruct.stControl.bExecute OR stAxisStruct.stStatus.bError);
        fbJog.Mode := 0;
        fbJog.Velocity := stAxisStruct.stConfig.fVelocity;
        fbJog.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbJog.Deceleration := stAxisStruct.stConfig.fDeceleration;

    E_MotionFunctions.eMoveVelocity:
        fbMoveVelocity.Execute := stAxisStruct.stControl.bExecute;
        fbMoveVelocity.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveVelocity.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveVelocity.Deceleration := stAxisStruct.stConfig.fDeceleration;
        fbMoveVelocity.Direction := SEL(stAxisStruct.stConfig.fVelocity < 0, MC_Positive_Direction, MC_Negative_Direction);

    E_MotionFunctions.eMoveModulo:
        fbMoveModulo.Execute := stAxisStruct.stControl.bExecute;
        fbMoveModulo.Position := stAxisStruct.stConfig.fPosition;
        fbMoveModulo.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveModulo.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveModulo.Deceleration := stAxisStruct.stConfig.fDeceleration;

    E_MotionFunctions.eGearIn:
        fbGearIn.Execute := stAxisStruct.stControl.bExecute;
        fbGearIn.RatioNumerator := stMasterAxis.fRatio;
        fbGearIn.RatioDenominator := nRATIO_DENOMINATOR_DEFAULT;

        IF NOT fbGearIn.InGear THEN
            stMasterAxis.nIndex := stAxisStruct.stConfig.stMasterAxis.nIndex;
            stMasterAxis.fRatio := stAxisStruct.stConfig.stMasterAxis.fRatio;
        END_IF

        //Confirm slaves have no gearing before attempting to gear in
         IF fbGearIn.InGear AND (GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] = nNO_GEARING) THEN
            GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] := stMasterAxis.fRatio;
        END_IF

    E_MotionFunctions.eGearInMultiMaster:
        IF stAxisStruct.stControl.bExecute AND NOT stAxisStruct.Axis.Status.Coupled THEN
            //Latch master references
            FOR iMultiMastersAxesIndex := 1 TO nMULTI_MASTER_MAX_AXES DO
                IF stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex > 0 AND stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex <= GVL_APP.nAXIS_NUM THEN
                    stAxisStruct.stConfig.astMultiMasterAxisLatched[iMultiMastersAxesIndex].nIndex := stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex;
                END_IF
            END_FOR
            //Latch gear ratios
            FOR iMultiMastersAxesIndex := 1 TO nMULTI_MASTER_MAX_AXES DO
                stAxisStruct.stConfig.astMultiMasterAxisLatched[iMultiMastersAxesIndex].fRatio := stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].fRatio;
            END_FOR
            //Transfer gear ratios to FB
            fbGearInMultiMaster.GearRatio1 := stAxisStruct.stConfig.astMultiMasterAxisLatched[1].fRatio;
            fbGearInMultiMaster.GearRatio2 := stAxisStruct.stConfig.astMultiMasterAxisLatched[2].fRatio;
            fbGearInMultiMaster.GearRatio3 := stAxisStruct.stConfig.astMultiMasterAxisLatched[3].fRatio;
            fbGearInMultiMaster.GearRatio4 := stAxisStruct.stConfig.astMultiMasterAxisLatched[4].fRatio;
            fbGearInMultiMaster.Enable := stAxisStruct.stControl.bExecute;
        END_IF

        IF fbGearInMultiMaster.Error THEN
            fbGearInMultiMaster.Enable := FALSE;
        END_IF

    E_MotionFunctions.eGearOut:
        fbGearOut.Execute := stAxisStruct.stControl.bExecute;
        fbGearInMultiMaster.Enable := FALSE;

        IF fbGearOut.Done THEN
            //Clear slave ratio from master axis slave array
            GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] := nNO_GEARING;
            FOR iSlaveAxesIndex := 1 TO GVL_APP.nAXIS_NUM DO
                GVL.astAxes[iSlaveAxesIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := nNO_GEARING;
            END_FOR
        END_IF

    E_MotionFunctions.eHome:
        fbHome.bExecute := stAxisStruct.stControl.bExecute;
        fbHome.bReset := stAxisStruct.stControl.bReset;
        fbHome.bStop := stAxisStruct.stControl.bStop;
        fbHome.eHomeProc := stAxisStruct.stConfig.eHomeSeq;
        fbHome.fHomePosition := stAxisStruct.stConfig.fHomePosition;
        fbHome.bLimitBwd := stAxisStruct.stInputs.bLimitBwd;
        fbHome.bLimitFwd := stAxisStruct.stInputs.bLimitFwd;
        fbHome.bHomeSensor := stAxisStruct.stInputs.bHomeSensor;
        stAxisStruct.stStatus.bHomed := fbHome.bHomed;
END_CASE

//Busy: It is sufficient to take the ouptuts from the eCommand function blocks
//Attention!! FB_Homing Output Busy has to be added after merging MBP-131
stAxisStruct.stStatus.bbusy := fbMoveAbsolute.Busy OR fbMoveRelative.Busy OR fbMoveVelocity.Busy
    OR fbMoveModulo.Busy OR fbJog.Busy OR fbGearIn.Busy OR fbGearInMultiMaster.Busy OR fbGearOut.Busy;

//CommandAborted from the eCommand function blocks
//Attention!! FB_Homing Output CommandAborted has to be added after merging MBP-131
fbCommandAbortedRiseEdge(CLK:= fbMoveAbsolute.CommandAborted OR fbMoveRelative.CommandAborted 
    OR fbMoveVelocity.CommandAborted OR fbMoveModulo.CommandAborted OR fbJog.CommandAborted 
    OR fbGearIn.CommandAborted OR fbGearInMultiMaster.CommandAborted OR fbHome.bWarning);
IF fbCommandAbortedRiseEdge.Q THEN stAxisStruct.stStatus.bCommandAborted := TRUE; END_IF

//Done from the eCommand function blocks
//Attention!! FB_Homing Output Done has to be added after merging MBP-131
fbDoneRiseEdge(CLK:= fbMoveAbsolute.Done OR fbMoveRelative.Done 
    OR fbMoveVelocity.InVelocity OR fbMoveModulo.Done OR fbJog.Done OR fbGearIn.InGear
    OR fbGearInMultiMaster.InGear OR fbGearOut.Done );
IF fbDoneRiseEdge.Q THEN 
    stAxisStruct.stStatus.bDone := TRUE; 
    stAxisStruct.stStatus.bCommandAborted:=FALSE;
END_IF

//Reset Done and CommandAborted with any new eCommand (Execute or Jog)
fbExecuteRiseEdge(CLK:=stAxisStruct.stControl.bExecute);
IF fbExecuteRiseEdge.Q THEN 
    stAxisStruct.stStatus.bDone := FALSE;
    stAxisStruct.stStatus.bCommandAborted := FALSE;
END_IF
fbJogRiseEdge(CLK:=stAxisStruct.stControl.bJogBwd OR stAxisStruct.stControl.bJogFwd);
IF fbJogRiseEdge.Q AND (stAxisStruct.stControl.eCommand = E_MotionFunctions.eJog) THEN 
    stAxisStruct.stStatus.bDone := FALSE;
    stAxisStruct.stStatus.bCommandAborted := FALSE;
END_IF

//Execution of fbReset ended
fbResetFinishedRiseEdge(CLK:=fbReset.Done OR FbReset.Error);
IF fbResetFinishedRiseEdge.Q THEN
    stAxisStruct.stControl.bReset := FALSE;
    stAxisStruct.stStatus.bError := FALSE;
    stAxisStruct.stStatus.nErrorID := 0;
    stAxisStruct.stError.nNCErrorID := 0;
    stAxisStruct.stError.nGearInErrorID := 0;
    stAxisStruct.stError.nGearInMultiMasterErrorID := 0;
    stAxisStruct.stError.nGearOutErrorID := 0;
    stAxisStruct.stError.nPowerErrorID := 0;
    stAxisStruct.stError.nResetErrorID := 0;
    stAxisStruct.stError.nStopErrorID := 0;
    stAxisStruct.stError.nHaltErrorID := 0;
    stAxisStruct.stError.nHomeErrorID := 0;
    stAxisStruct.stError.nJogErrorID := 0;
    stAxisStruct.stError.nMoveAbsoluteErrorID := 0;
    stAxisStruct.stError.nMoveRelativeErrorID := 0;
    stAxisStruct.stError.nMoveModuloErrorID := 0;
    stAxisStruct.stError.nMoveVelocityErrorID := 0;
    stAxisStruct.stControl.bExecute := FALSE;
    stAxisStruct.stControl.bStop := FALSE;
    stAxisStruct.stControl.bReset := FALSE;
    stAxisStruct.stControl.bJogBwd := FALSE;
    stAxisStruct.stControl.bJogFwd := FALSE;
END_IF


//Execution of fbStop ended
fbStopFinishedRiseEdge(CLK:=fbStop.Done OR fbStop.Error OR fbStop.CommandAborted);
IF fbStopFinishedRiseEdge.Q THEN
    stAxisStruct.stControl.bStop := FALSE;
END_IF

//Save the errors from the PLCopen motion functions blocks and from the NC
IF fbPower.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbPower.ErrorID;
    stAxisStruct.stError.nPowerErrorID := fbPower.ErrorID;

ELSIF fbHalt.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbHalt.ErrorID;
    stAxisStruct.stError.nHaltErrorID := fbHalt.ErrorID;

ELSIF fbStop.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbStop.ErrorID;
    stAxisStruct.stError.nStopErrorID := fbStop.ErrorID;

ELSIF fbReset.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbReset.ErrorID;
    stAxisStruct.stError.nResetErrorID := fbReset.ErrorID;

ELSIF fbJog.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbJog.ErrorID;
    stAxisStruct.stError.nJogErrorID := fbJog.ErrorID;

ELSIF fbMoveVelocity.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveVelocity.ErrorID;
    stAxisStruct.stError.nMoveVelocityErrorID := fbMoveVelocity.ErrorID;

ELSIF fbMoveRelative.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveRelative.ErrorID;
    stAxisStruct.stError.nMoveRelativeErrorID := fbMoveRelative.ErrorID;

ELSIF fbMoveAbsolute.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveAbsolute.ErrorID;
    stAxisStruct.stError.nMoveAbsoluteErrorID := fbMoveAbsolute.ErrorID;

ELSIF fbMoveModulo.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveModulo.ErrorID;
    stAxisStruct.stError.nMoveModuloErrorID := fbMoveModulo.ErrorID;

ELSIF fbHome.bError THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbHome.nErrorID;
    stAxisStruct.stError.nHomeErrorID := fbHome.nErrorID;

ELSIF fbGearIn.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbGearIn.ErrorID;
    stAxisStruct.stError.nGearInErrorId:=fbGearIn.ErrorID;

ELSIF fbGearInMultiMaster.Error THEN
    stAxisStruct.stStatus.bError:=TRUE;
    stAxisStruct.stStatus.nErrorId:=fbGearInMultiMaster.ErrorID;
    stAxisStruct.stError.nGearInMultiMasterErrorId:=fbGearInMultiMaster.ErrorID;

ELSIF fbGearOut.Error and stAxisStruct.Axis.Status.Coupled THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbGearOut.ErrorID;
    stAxisStruct.stError.nGearOutErrorId := fbGearOut.ErrorID;

ELSIF stAxisStruct.Axis.Status.Error THEN
    stAxisStruct.stStatus.bError := stAxisStruct.Axis.Status.Error;
    stAxisStruct.stStatus.nErrorId := stAxisStruct.Axis.Status.ErrorID;
    stAxisStruct.stError.nNCErrorId := stAxisStruct.Axis.Status.ErrorID;

END_IF;

//Actual Velocity
stAxisStruct.stStatus.fActVelocity := stAxisStruct.Axis.NcToPlc.ActVelo;

//Actual Position
IF stAxisStruct.Axis.Status.OpMode.Modulo THEN
    stAxisStruct.stStatus.fActPosition := stAxisStruct.Axis.NcToPlc.ModuloActPos;
ELSE
    stAxisStruct.stStatus.fActPosition := stAxisStruct.Axis.NcToPlc.ActPos;
END_IF

//Moving Status from the NC
stAxisStruct.stStatus.bMoving := stAxisStruct.Axis.Status.Moving;

//Gearing Status from the NC
stAxisStruct.stStatus.bGeared := stAxisStruct.Axis.Status.Coupled;

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio1 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio1;
    stAxisStruct.stStatus.bCoupledGear1 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear1 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio2 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio2;
    stAxisStruct.stStatus.bCoupledGear2 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear2 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio3 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio3;
    stAxisStruct.stStatus.bCoupledGear3 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear3 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio4 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio4;
    stAxisStruct.stStatus.bCoupledGear4 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear4 := FALSE;
END_IF

//Reset bExecute
stAxisStruct.stControl.bExecute := FALSE;]]></ST>
    </Implementation>
    <LineIds Name="FB_Axis">
      <LineId Id="4709" Count="201" />
      <LineId Id="5066" Count="3" />
      <LineId Id="5065" Count="0" />
      <LineId Id="4911" Count="152" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>