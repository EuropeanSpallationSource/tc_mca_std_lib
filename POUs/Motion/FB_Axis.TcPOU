<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Axis" Id="{45901cd0-c6d2-4114-b7cf-de832171219f}" SpecialFunc="None">
    <Declaration><![CDATA[//Function block to run a virtual drive with Nc
FUNCTION_BLOCK FB_Axis
VAR
    sVersion: STRING := '1.0.4';
END_VAR

VAR CONSTANT
    nMULTI_MASTER_MAX_AXES: UINT := 4;
    //Kept static as numerator is LREAL and consistent with multigearing
    nRATIO_DENOMINATOR_DEFAULT: UINT := 1;
    //By default 0 as represents no existing gearing
    nNO_GEARING: UINT := 0;
END_VAR

VAR_IN_OUT
    stAxisStruct: ST_AxisStruct;
END_VAR

VAR
    iAxisIndex: UINT;
    iMultiMastersAxesIndex: UINT;
    iSlaveAxesIndex: UINT;
    bWaitForStoppingAfterLimitHit : BOOL := FALSE;
    fbRemovePowerTimer: TOF;
    stMasterAxis: ST_GearAxis := (nIndex := 1, fRatio := 0);
    fbReset: MC_Reset;
    fbPower: MC_Power;
    fbStop: MC_Stop;
    fbHalt: MC_Halt;
    fbJog: MC_Jog;
    fbMoveAbsolute: MC_MoveAbsolute;
    fbMoveVelocity: MC_MoveVelocity;
    fbMoveRelative: MC_MoveRelative;
    fbMoveModulo: MC_MoveModulo;
    fbGearIn: MC_GearIn;
    fbGearOut: MC_GearOut;
    fbGearInMultiMaster: MC_GearInMultiMaster;
    fbHome: FB_Homing;
    fbExecuteRiseEdge: R_TRIG;
    fbJogRiseEdge: R_TRIG;
    fbStopRiseEdge: R_TRIG;
    fbResetRiseEdge: R_TRIG;
    fbStopFinishedRiseEdge: R_TRIG;
    fbResetFinishedRiseEdge: R_TRIG;
    fbCommandAbortedRiseEdge: R_TRIG;
    fbDoneRiseEdge: R_TRIG;
    fbWriteParameter: MC_WriteParameter;
    fbReadParameter: MC_ReadParameter;	
	bDoneEdge: BOOL; // helper variable for the detection of a rising edge of the done output of any motion FBs
	bCommandAbortedEdge: BOOL; // helper variable for the detection of a rising edge of the commandAborted output of any motion FBs
	bBusy: BOOL; // helper variable for a logical OR of the busy output of all motion FBs
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[bBusy := FALSE;

stAxisStruct.Axis.ReadStatus();

//Call of all MC Instances and set all Executes to FALSE
fbPower(Axis := stAxisStruct.Axis);
fbPower.Enable := FALSE;

fbReset(Axis := stAxisStruct.Axis);
fbReset.Execute := FALSE;
bBUSY:= bBUSY OR fbReset.Busy;

fbStop(Axis := stAxisStruct.Axis);
fbStop.Execute := FALSE;
bBUSY:= bBUSY OR fbStop.Busy;

fbHalt(Axis := stAxisStruct.Axis);
fbHalt.Execute := FALSE;
bBUSY:= bBUSY OR fbHalt.Busy;

fbJog(Axis := stAxisStruct.Axis);
bBUSY:= bBUSY OR fbJog.Busy;

fbHome(Axis := stAxisStruct.Axis,
bLimitBwd := stAxisStruct.stInputs.bLimitBwd,
bLimitFwd := stAxisStruct.stInputs.bLimitFwd,
bHomeSensor := stAxisStruct.stInputs.bHomeSensor);
fbHome.bExecute := FALSE;
bBUSY:= bBUSY OR fbHome.bBusy;

fbMoveAbsolute(Axis := stAxisStruct.Axis);
fbMoveAbsolute.Execute := FALSE;
bBUSY:= bBUSY OR fbMoveAbsolute.Busy;

fbMoveRelative(Axis := stAxisStruct.Axis);
fbMoveRelative.Execute := FALSE;
bBUSY:= bBUSY OR fbReset.Busy;

fbMoveVelocity(Axis := stAxisStruct.Axis);
fbMoveVelocity.Execute := FALSE;
bBUSY:= bBUSY OR fbMoveRelative.Busy;

fbMoveModulo(Axis := stAxisStruct.Axis);
fbMoveModulo.Execute := FALSE;
bBUSY:= bBUSY OR fbMoveModulo.Busy;

fbGearin(Slave := stAxisStruct.Axis, Master := GVL.astAxes[stMasterAxis.nIndex].Axis);
fbGearIn.Execute := FALSE;
bBUSY:= bBUSY OR fbGearin.Busy;

fbGearInMultiMaster(Slave := stAxisStruct.Axis,
    Master1 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex].Axis,
    Master2 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex].Axis,
    Master3 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex].Axis,
    Master4 := GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex].Axis);
bBUSY:= bBUSY OR fbGearInMultiMaster.Busy;

fbGearOut(Slave := stAxisStruct.Axis);
fbGearOut.Execute := FALSE;
bBUSY:= bBUSY OR fbGearOut.Busy;

fbWriteParameter(Axis := stAxisStruct.Axis);
fbWriteParameter.Execute := FALSE;
bBUSY:= bBUSY OR fbWriteParameter.Busy;

//Read parameter continuously
fbReadParameter(
    Axis := stAxisStruct.Axis,
    Enable := TRUE,
    ParameterNumber := stAxisStruct.stconfig.eAxisParameters,
    ReadMode := READMODE_CYCLIC);
//do no evaluate fbReadParameter.busy, since this is continuously TRUE

IF NOT fbReadParameter.Error THEN
    stAxisStruct.stConfig.bReadAxisParameterValid := fbReadParameter.Valid;
    stAxisStruct.stconfig.fReadAxisParameter := fbReadParameter.Value;
END_IF

fbWriteParameter(Axis := stAxisStruct.Axis);
fbWriteParameter.Execute := FALSE;

//Read parameter continuously
fbReadParameter(
    Axis := stAxisStruct.Axis,
    Enable := TRUE,
    ParameterNumber := stAxisStruct.stconfig.eAxisParameters,
    ReadMode := READMODE_CYCLIC);

IF NOT fbReadParameter.Error THEN
    stAxisStruct.stConfig.bReadAxisParameterValid := fbReadParameter.Valid;
    stAxisStruct.stconfig.fReadAxisParameter := fbReadParameter.Value;
END_IF

//Linking the limit swtiches
stAxisStruct.stStatus.bFwEnabled := stAxisStruct.stInputs.bLimitFwd;
stAxisStruct.stStatus.bBwEnabled := stAxisStruct.stInputs.bLimitBwd;

FOR iAxisIndex := 1 TO GVL_APP.nAXIS_NUM DO
    IF (stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] <> 0) THEN
        stAxisStruct.stStatus.bFwEnabled := stAxisStruct.stStatus.bFwEnabled AND SEL(stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] > 0, GVL.astAxes[iAxisIndex].stStatus.bBwEnabled, GVL.astAxes[iAxisIndex].stStatus.bFwEnabled);
        stAxisStruct.stStatus.bBwEnabled := stAxisStruct.stStatus.bBwEnabled AND SEL(stAxisStruct.stConfig.afMultiSlaveAxisRatio[iAxisIndex] > 0, GVL.astAxes[iAxisIndex].stStatus.bFwEnabled, GVL.astAxes[iAxisIndex].stStatus.bBwEnabled);
    END_IF
END_FOR

//Timer for keeping power on after limit switch hit, needed for homing routines - if power is lost routines are aborted
fbRemovePowerTimer(IN := stAxisStruct.stInputs.bLimitFwd AND stAxisStruct.stInputs.bLimitBwd, PT := T#100MS);
IF fbHome.bBusy AND (fbRemovePowerTimer.Q OR stAxisStruct.Axis.NcToPlc.AxisState=5) THEN //5=PHASE_ACCNEG
    bWaitForStoppingAfterLimitHit := TRUE;
ELSE
    bWaitForStoppingAfterLimitHit := FALSE;
END_IF

//Power
fbPower.Enable := stAxisStruct.stControl.bEnable;
fbPower.Enable_Positive := stAxisStruct.stStatus.bFwEnabled OR bWaitForStoppingAfterLimitHit;
fbPower.Enable_Negative := stAxisStruct.stStatus.bBwEnabled OR bWaitForStoppingAfterLimitHit;
fbPower.Override := stAxisStruct.stConfig.fOverride;
stAxisStruct.stStatus.bEnabled := fbPower.Status;

//Stop
fbStop.Execute := stAxisStruct.stControl.bStop;
fbStop.Deceleration := stAxisStruct.stConfig.fDeceleration;

//Reset only if axis is in error state
IF stAxisStruct.stStatus.bError THEN
    fbReset.Execute := stAxisStruct.stControl.bReset;
ELSE
    stAxisStruct.stControl.bReset := FALSE;
END_IF

//Motion Functions
CASE stAxisStruct.stControl.eCommand OF
    E_MotionFunctions.eMoveAbsolute:
        fbMoveAbsolute.Execute := stAxisStruct.stControl.bExecute;
        fbMoveAbsolute.Position := stAxisStruct.stConfig.fPosition;
        fbMoveAbsolute.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveAbsolute.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveAbsolute.Deceleration := stAxisStruct.stConfig.fDeceleration;
        bDoneEdge := fbMoveAbsolute.Done;
        bCommandAbortedEdge := fbMoveAbsolute.CommandAborted;

    E_MotionFunctions.eMoveRelative:
        fbMoveRelative.Execute := stAxisStruct.stControl.bExecute;
        fbMoveRelative.Distance := stAxisStruct.stConfig.fPosition;
        fbMoveRelative.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveRelative.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveRelative.Deceleration := stAxisStruct.stConfig.fDeceleration;
        bDoneEdge := fbMoveRelative.Done;
        bCommandAbortedEdge := fbMoveRelative.CommandAborted;

    E_MotionFunctions.eJog:
        fbJog.JogForward := stAxisStruct.stControl.bJogFwd AND NOT (stAxisStruct.stControl.bExecute OR stAxisStruct.stStatus.bError);
        fbJog.JogBackwards := stAxisStruct.stControl.bJogBwd AND NOT (stAxisStruct.stControl.bExecute OR stAxisStruct.stStatus.bError);
        fbJog.Mode := 0;
        fbJog.Velocity := stAxisStruct.stConfig.fVelocity;
        fbJog.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbJog.Deceleration := stAxisStruct.stConfig.fDeceleration;
        bDoneEdge := fbJog.Done;
        bCommandAbortedEdge := fbJog.CommandAborted;

    E_MotionFunctions.eMoveVelocity:
        fbMoveVelocity.Execute := stAxisStruct.stControl.bExecute;
        fbMoveVelocity.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveVelocity.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveVelocity.Deceleration := stAxisStruct.stConfig.fDeceleration;
        fbMoveVelocity.Direction := SEL(stAxisStruct.stConfig.fVelocity < 0, MC_Positive_Direction, MC_Negative_Direction);
        bCommandAbortedEdge := fbMoveVelocity.CommandAborted;

    E_MotionFunctions.eMoveModulo:
        fbMoveModulo.Execute := stAxisStruct.stControl.bExecute;
        fbMoveModulo.Position := stAxisStruct.stConfig.fPosition;
        fbMoveModulo.Velocity := ABS(stAxisStruct.stConfig.fVelocity);
        fbMoveModulo.Acceleration := stAxisStruct.stConfig.fAcceleration;
        fbMoveModulo.Deceleration := stAxisStruct.stConfig.fDeceleration;
        bDoneEdge := fbMoveModulo.Done;
        bCommandAbortedEdge := fbMoveModulo.CommandAborted;

    E_MotionFunctions.eGearIn:
        fbGearIn.Execute := stAxisStruct.stControl.bExecute;
        fbGearIn.RatioNumerator := stMasterAxis.fRatio;
        fbGearIn.RatioDenominator := nRATIO_DENOMINATOR_DEFAULT;
        bCommandAbortedEdge := fbGearIn.CommandAborted;

        IF NOT fbGearIn.InGear THEN
            stMasterAxis.nIndex := stAxisStruct.stConfig.stMasterAxis.nIndex;
            stMasterAxis.fRatio := stAxisStruct.stConfig.stMasterAxis.fRatio;
        END_IF

        //Confirm slaves have no gearing before attempting to gear in
         IF fbGearIn.InGear AND (GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] = nNO_GEARING) THEN
            GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] := stMasterAxis.fRatio;
        END_IF

    E_MotionFunctions.eGearInMultiMaster:
        bCommandAbortedEdge := fbGearInMultiMaster.CommandAborted;

        IF stAxisStruct.stControl.bExecute AND NOT stAxisStruct.Axis.Status.Coupled THEN
            //Latch master references
            FOR iMultiMastersAxesIndex := 1 TO nMULTI_MASTER_MAX_AXES DO
                IF stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex > 0 AND stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex <= GVL_APP.nAXIS_NUM THEN
                    stAxisStruct.stConfig.astMultiMasterAxisLatched[iMultiMastersAxesIndex].nIndex := stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].nIndex;
                END_IF
            END_FOR
            //Latch gear ratios
            FOR iMultiMastersAxesIndex := 1 TO nMULTI_MASTER_MAX_AXES DO
                stAxisStruct.stConfig.astMultiMasterAxisLatched[iMultiMastersAxesIndex].fRatio := stAxisStruct.stConfig.astMultiMasterAxis[iMultiMastersAxesIndex].fRatio;
            END_FOR
            //Transfer gear ratios to FB
            fbGearInMultiMaster.GearRatio1 := stAxisStruct.stConfig.astMultiMasterAxisLatched[1].fRatio;
            fbGearInMultiMaster.GearRatio2 := stAxisStruct.stConfig.astMultiMasterAxisLatched[2].fRatio;
            fbGearInMultiMaster.GearRatio3 := stAxisStruct.stConfig.astMultiMasterAxisLatched[3].fRatio;
            fbGearInMultiMaster.GearRatio4 := stAxisStruct.stConfig.astMultiMasterAxisLatched[4].fRatio;
            fbGearInMultiMaster.Enable := stAxisStruct.stControl.bExecute;
        END_IF

        IF fbGearInMultiMaster.Error THEN
            fbGearInMultiMaster.Enable := FALSE;
        END_IF

    E_MotionFunctions.eGearOut:
        fbGearOut.Execute := stAxisStruct.stControl.bExecute;
        fbGearInMultiMaster.Enable := FALSE;
        bDoneEdge := fbGearOut.Done;

        IF fbGearOut.Done THEN
            //Clear slave ratio from master axis slave array
            GVL.astAxes[stMasterAxis.nIndex].stConfig.afSlaveAxisRatio[GVL.iAxis] := nNO_GEARING;
            FOR iSlaveAxesIndex := 1 TO GVL_APP.nAXIS_NUM DO
                GVL.astAxes[iSlaveAxesIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := nNO_GEARING;
            END_FOR
        END_IF

    E_MotionFunctions.eHome:
        fbHome.bExecute := stAxisStruct.stControl.bExecute AND NOT stAxisStruct.stStatus.bError;
        fbHome.eHomeSeq := stAxisStruct.stConfig.eHomeSeq;
        fbHome.fHomePosition := stAxisStruct.stConfig.fHomePosition;
        fbHome.fHomeFinishDistance := stAxisStruct.stConfig.fHomeFinishDistance;
        bDoneEdge := fbHome.bDone;
        bCommandAbortedEdge := fbHome.bCommandAborted;

    E_MotionFunctions.eWriteParameter:
        fbWriteParameter.Execute := stAxisStruct.stcontrol.bExecute;
        fbWriteParameter.ParameterNumber := stAxisStruct.stConfig.eAxisParameters;
        fbWriteParameter.Value := stAxisStruct.stConfig.fWriteAxisParameter;
        bDoneEdge := fbWriteParameter.Done;

END_CASE

//Busy from the motion function blocks
stAxisStruct.stStatus.bBusy := bBusy;

//CommandAborted from the eCommand function blocks
fbCommandAbortedRiseEdge(CLK:= bCommandAbortedEdge);
IF fbCommandAbortedRiseEdge.Q THEN 
    stAxisStruct.stStatus.bCommandAborted := TRUE; 
END_IF

//Done from the eCommand function blocks
fbDoneRiseEdge(CLK:= bDoneEdge);
IF fbDoneRiseEdge.Q THEN
    stAxisStruct.stStatus.bDone := TRUE;
    stAxisStruct.stStatus.bCommandAborted:=FALSE;
END_IF

//Reset Done and CommandAborted with any new eCommand (Execute or Jog)
fbExecuteRiseEdge(CLK:=stAxisStruct.stControl.bExecute);
IF fbExecuteRiseEdge.Q THEN
    stAxisStruct.stStatus.bDone := FALSE;
    stAxisStruct.stStatus.bCommandAborted := FALSE;
END_IF
fbJogRiseEdge(CLK:=stAxisStruct.stControl.bJogBwd OR stAxisStruct.stControl.bJogFwd);
IF fbJogRiseEdge.Q AND (stAxisStruct.stControl.eCommand = E_MotionFunctions.eJog) THEN
    stAxisStruct.stStatus.bDone := FALSE;
    stAxisStruct.stStatus.bCommandAborted := FALSE;
END_IF

//Execution of fbReset ended
fbResetFinishedRiseEdge(CLK:=fbReset.Done OR FbReset.Error);
IF fbResetFinishedRiseEdge.Q THEN
    stAxisStruct.stControl.bReset := FALSE;
    stAxisStruct.stStatus.bError := FALSE;
    stAxisStruct.stStatus.nErrorID := 0;
    stAxisStruct.stError.nNCErrorID := 0;
    stAxisStruct.stError.nGearInErrorID := 0;
    stAxisStruct.stError.nGearInMultiMasterErrorID := 0;
    stAxisStruct.stError.nGearOutErrorID := 0;
    stAxisStruct.stError.fbReadParameterErrorId := 0;
    stAxisStruct.stError.fbWriteParameterErrorId := 0;
    stAxisStruct.stError.nPowerErrorID := 0;
    stAxisStruct.stError.nResetErrorID := 0;
    stAxisStruct.stError.nStopErrorID := 0;
    stAxisStruct.stError.nHaltErrorID := 0;
    stAxisStruct.stError.nHomeErrorID := 0;
    stAxisStruct.stError.nJogErrorID := 0;
    stAxisStruct.stError.nMoveAbsoluteErrorID := 0;
    stAxisStruct.stError.nMoveRelativeErrorID := 0;
    stAxisStruct.stError.nMoveModuloErrorID := 0;
    stAxisStruct.stError.nMoveVelocityErrorID := 0;
    stAxisStruct.stControl.bExecute := FALSE;
    stAxisStruct.stControl.bStop := FALSE;
    stAxisStruct.stControl.bReset := FALSE;
    stAxisStruct.stControl.bJogBwd := FALSE;
    stAxisStruct.stControl.bJogFwd := FALSE;
END_IF

//Execution of fbStop ended
fbStopFinishedRiseEdge(CLK:=fbStop.Done OR fbStop.Error OR fbStop.CommandAborted);
IF fbStopFinishedRiseEdge.Q THEN
    stAxisStruct.stControl.bStop := FALSE;
END_IF

//Save the errors from the PLCopen motion functions blocks and from the NC
IF fbPower.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbPower.ErrorID;
    stAxisStruct.stError.nPowerErrorID := fbPower.ErrorID;

ELSIF fbHalt.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbHalt.ErrorID;
    stAxisStruct.stError.nHaltErrorID := fbHalt.ErrorID;

ELSIF fbStop.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbStop.ErrorID;
    stAxisStruct.stError.nStopErrorID := fbStop.ErrorID;

ELSIF fbReset.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbReset.ErrorID;
    stAxisStruct.stError.nResetErrorID := fbReset.ErrorID;

ELSIF fbJog.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbJog.ErrorID;
    stAxisStruct.stError.nJogErrorID := fbJog.ErrorID;

ELSIF fbMoveVelocity.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveVelocity.ErrorID;
    stAxisStruct.stError.nMoveVelocityErrorID := fbMoveVelocity.ErrorID;

ELSIF fbMoveRelative.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveRelative.ErrorID;
    stAxisStruct.stError.nMoveRelativeErrorID := fbMoveRelative.ErrorID;

ELSIF fbMoveAbsolute.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveAbsolute.ErrorID;
    stAxisStruct.stError.nMoveAbsoluteErrorID := fbMoveAbsolute.ErrorID;

ELSIF fbMoveModulo.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbMoveModulo.ErrorID;
    stAxisStruct.stError.nMoveModuloErrorID := fbMoveModulo.ErrorID;

ELSIF fbHome.bError THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbHome.nErrorID;
    stAxisStruct.stError.nHomeErrorID := fbHome.nErrorID;

ELSIF fbGearIn.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbGearIn.ErrorID;
    stAxisStruct.stError.nGearInErrorId:=fbGearIn.ErrorID;
	
ELSIF fbGearInMultiMaster.Error THEN
    stAxisStruct.stStatus.bError:=TRUE;
    stAxisStruct.stStatus.nErrorId:=fbGearInMultiMaster.ErrorID;
    stAxisStruct.stError.nGearInMultiMasterErrorId:=fbGearInMultiMaster.ErrorID;

ELSIF fbGearOut.Error and stAxisStruct.Axis.Status.Coupled THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbGearOut.ErrorID;
    stAxisStruct.stError.nGearOutErrorId := fbGearOut.ErrorID;

ELSIF fbWriteParameter.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbWriteParameter.ErrorID;
    stAxisStruct.stError.fbWriteParameterErrorId:=fbWriteParameter.ErrorID;

ELSIF fbReadParameter.Error THEN
    stAxisStruct.stStatus.bError := TRUE;
    stAxisStruct.stStatus.nErrorId := fbReadParameter.ErrorID;
    stAxisStruct.stError.fbReadParameterErrorId:=fbReadParameter.ErrorID;

ELSIF stAxisStruct.Axis.Status.Error THEN
    stAxisStruct.stStatus.bError := stAxisStruct.Axis.Status.Error;
    stAxisStruct.stStatus.nErrorId := stAxisStruct.Axis.Status.ErrorID;
    stAxisStruct.stError.nNCErrorId := stAxisStruct.Axis.Status.ErrorID;

END_IF;

//Actual Velocity
stAxisStruct.stStatus.fActVelocity := stAxisStruct.Axis.NcToPlc.ActVelo;

//Actual Position
IF stAxisStruct.Axis.Status.OpMode.Modulo THEN
    stAxisStruct.stStatus.fActPosition := stAxisStruct.Axis.NcToPlc.ModuloActPos;
ELSE
    stAxisStruct.stStatus.fActPosition := stAxisStruct.Axis.NcToPlc.ActPos;
END_IF

//Homing status
stAxisStruct.stStatus.bHomed := stAxisStruct.Axis.Status.Homed;

//Moving Status from the NC
stAxisStruct.stStatus.bMoving := stAxisStruct.Axis.Status.Moving;

//Gearing Status from the NC
stAxisStruct.stStatus.bGeared := stAxisStruct.Axis.Status.Coupled;

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio1 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[1].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio1;
    stAxisStruct.stStatus.bCoupledGear1 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear1 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio2 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[2].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio2;
    stAxisStruct.stStatus.bCoupledGear2 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear2 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio3 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[3].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio3;
    stAxisStruct.stStatus.bCoupledGear3 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear3 := FALSE;
END_IF

IF stAxisStruct.Axis.Status.Coupled AND stAxisStruct.Axis.PlcToNc.GearRatio4 <> 0 AND stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex <> 0 THEN
    GVL.astAxes[stAxisStruct.stConfig.astMultiMasterAxisLatched[4].nIndex].stConfig.afMultiSlaveAxisRatio[GVL.iAxis] := stAxisStruct.Axis.PlcToNc.GearRatio4;
    stAxisStruct.stStatus.bCoupledGear4 := TRUE;
ELSE
    stAxisStruct.stStatus.bCoupledGear4 := FALSE;
END_IF

//Reset bExecute
stAxisStruct.stControl.bExecute := FALSE;]]></ST>
    </Implementation>
    <LineIds Name="FB_Axis">
      <LineId Id="5284" Count="1" />
      <LineId Id="4709" Count="7" />
      <LineId Id="5287" Count="0" />
      <LineId Id="4717" Count="2" />
      <LineId Id="5288" Count="0" />
      <LineId Id="4720" Count="2" />
      <LineId Id="5289" Count="0" />
      <LineId Id="4723" Count="1" />
      <LineId Id="5290" Count="0" />
      <LineId Id="4725" Count="0" />
      <LineId Id="5118" Count="3" />
      <LineId Id="4727" Count="0" />
      <LineId Id="5291" Count="0" />
      <LineId Id="4728" Count="2" />
      <LineId Id="5292" Count="0" />
      <LineId Id="4731" Count="2" />
      <LineId Id="5293" Count="0" />
      <LineId Id="4734" Count="2" />
      <LineId Id="5294" Count="0" />
      <LineId Id="4737" Count="2" />
      <LineId Id="5295" Count="0" />
      <LineId Id="4740" Count="2" />
      <LineId Id="5296" Count="0" />
      <LineId Id="4743" Count="5" />
      <LineId Id="5297" Count="0" />
      <LineId Id="4749" Count="2" />
      <LineId Id="5298" Count="0" />
      <LineId Id="5232" Count="2" />
      <LineId Id="5299" Count="0" />
      <LineId Id="5235" Count="6" />
      <LineId Id="5300" Count="0" />
      <LineId Id="5242" Count="4" />
      <LineId Id="4752" Count="10" />
      <LineId Id="5122" Count="7" />
      <LineId Id="4763" Count="26" />
      <LineId Id="5301" Count="1" />
      <LineId Id="4790" Count="6" />
      <LineId Id="5304" Count="1" />
      <LineId Id="4797" Count="7" />
      <LineId Id="5306" Count="1" />
      <LineId Id="4805" Count="6" />
      <LineId Id="5309" Count="0" />
      <LineId Id="4812" Count="6" />
      <LineId Id="5310" Count="1" />
      <LineId Id="4819" Count="4" />
      <LineId Id="5313" Count="0" />
      <LineId Id="4824" Count="11" />
      <LineId Id="5316" Count="0" />
      <LineId Id="5314" Count="0" />
      <LineId Id="4836" Count="25" />
      <LineId Id="5317" Count="0" />
      <LineId Id="4862" Count="9" />
      <LineId Id="5115" Count="2" />
      <LineId Id="4880" Count="0" />
      <LineId Id="5319" Count="1" />
      <LineId Id="5253" Count="0" />
      <LineId Id="5248" Count="3" />
      <LineId Id="5321" Count="0" />
      <LineId Id="5247" Count="0" />
      <LineId Id="4881" Count="2" />
      <LineId Id="5182" Count="0" />
      <LineId Id="4887" Count="1" />
      <LineId Id="4892" Count="1" />
      <LineId Id="5275" Count="1" />
      <LineId Id="4894" Count="1" />
      <LineId Id="4899" Count="11" />
      <LineId Id="5066" Count="3" />
      <LineId Id="5065" Count="0" />
      <LineId Id="4911" Count="10" />
      <LineId Id="5278" Count="1" />
      <LineId Id="4922" Count="15" />
      <LineId Id="4939" Count="71" />
      <LineId Id="5265" Count="9" />
      <LineId Id="5011" Count="16" />
      <LineId Id="5132" Count="0" />
      <LineId Id="5134" Count="1" />
      <LineId Id="5028" Count="35" />
      <LineId Id="2" Count="0" />
      <LineId Id="267" Count="80" />
    </LineIds>
  </POU>
</TcPlcObject>
