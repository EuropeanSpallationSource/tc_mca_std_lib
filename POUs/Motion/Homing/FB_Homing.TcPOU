<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Homing" Id="{e8b732be-06ce-4dd5-944d-e7ad6eae8e67}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Homing
VAR_INPUT
    bExecute: BOOL;
    bReset: BOOL;
    bStop: BOOL;
    nHomeProc: UINT;
    bLimitBwd: BOOL;
    bLimitFwd: BOOL;
    bHomeSensor: BOOL;
    fHomePosition: LREAL;
END_VAR
VAR_IN_OUT
    Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
    bHomed: BOOL;
    bError: BOOL;
    bWarning: BOOL;
    nErrorId: UDINT;
END_VAR
VAR
    bHomingInProgress: BOOL;
    bReadNcVelocities: BOOL;
    nHomeProcLocal: UINT := 0;
    nHomingState: INT := 0;
    tLimit: TIME :=  T#0H10M;
//Homing Structures
    stTrigger: TRIGGER_REF;
    stLimitSwRef: MC_Ref_Signal_Ref;
    stLimitSwRef2: MC_Ref_Signal_Ref;
    stHomeSwRef: MC_Ref_Signal_Ref;
    stIndexRef: MC_Ref_Signal_Ref;
    stHomingParameter: MC_HomingParameter;
    stOptions2: ST_Home_Options2;
    stOptions4: ST_Home_Options4;
//Homing FB's
    fbExecuteRiseEdge: R_TRIG;
    fbStepLimitSwitch: MC_StepLimitSwitch;
    fbStepLimitSwitchDetection: MC_StepLimitSwitchDetection;
    fbStepAbsoluteSwitch: MC_StepAbsoluteSwitch;
    fbStepReferencePulse: MC_StepReferencePulse;
    fbHomeDirect: MC_HomeDirect;
    fbAbortHoming: MC_AbortHoming;
    fbFinishHoming: MC_FinishHoming;
    fbHomeReadNCVelocities: FB_HomeReadNCVelocities;


END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbExecuteRiseEdge();
fbStepLimitSwitch(Axis:= Axis, Parameter:= stHomingParameter);
fbStepLimitSwitchDetection(Axis:= Axis, Parameter:= stHomingParameter);
fbStepAbsoluteSwitch(Axis:= Axis, Parameter:= stHomingParameter);
fbStepReferencePulse(Axis:= Axis, Parameter:= stHomingParameter);
fbHomeDirect(Axis:= Axis, Parameter:= stHomingParameter);
fbAbortHoming(Axis:= Axis, Parameter:= stHomingParameter);
fbFinishHoming(Axis:= Axis, Parameter:= stHomingParameter);
fbHomeReadNCVelocities(Axis:= Axis);

IF bReset THEN
    bError := FALSE;
    bWarning := FALSE;
    bReadNcVelocities := FALSE;
    bHomingInProgress := FALSE;
    fbAbortHoming.Execute := FALSE;
    nErrorId := 0;
    nHomingState := 0;
END_IF

IF bStop THEN
    bReadNcVelocities := FALSE;
    bHomingInProgress := FALSE;
    nHomingState := 0;
END_IF

fbExecuteRiseEdge.CLK := bExecute;
IF fbExecuteRiseEdge.Q THEN
    bHomingInProgress := TRUE;
    bReadNcVelocities := TRUE;
    fbAbortHoming.Execute := FALSE;
    nHomeProcLocal := nHomeProc;
(*   CASE nHomeProcLocal OF
      //0X: LIMIT Switch
      01: //Home to bBwdLimit (reverse off limit)
      02: //Home to bFwdLimit (reverse off limit)
      03: //Home to bBwdLimit (two speeds)
      04: //Home to bFwdLimit (two speeds)
      //1X: Home Sensor
      11: //Home to bHome in Bwd direction (single speed - will reverse back if limit hit)
      12: //Home to bHome in Fwd direction (single speed - will reverse back if limit hit)
      13: //Home to bHome via bBwdLimit (two speeds)
      14: //Home to bHome via bFwdLimit (two speeds)
      //2X: Enc Pulse
      21: //Home to EncRefPulse in Bwd direction (single speed - will reverse back if limit hit)
      22: //Home to EncRefPulse in Fwd direction (single speed - will reverse back if limit hit)
      23: //Home to EncRefPulse via bBwdLimit (two speeds)
      24: //Home to EncRefPulse via bFwdLimit (two speeds)
      //9X: Software
      90: //Home direct to value *)
ELSE
      bError:=TRUE;
      bHomingInProgress := FALSE;
      nErrorId:=16#4FFF;
  //END_CASE
END_IF

IF bHomingInProgress AND fbHomeReadNcVelocities.bDone AND NOT bError THEN
CASE nHomeProcLocal OF
   1,2: //Home to bLimitBwd(1) or bLimitFwd(2)
        CASE nHomingState OF
          0:
            fbStepLimitSwitch.Execute:=FALSE;
            fbStepLimitSwitch.LimitSwitchMode:=mcFallingEdge;
            fbStepLimitSwitch.Velocity:=fbHomeReadNcVelocities.fVelocityFromCam;
            fbStepLimitSwitch.Setposition:=fHomePosition;
            CASE nHomeProcLocal OF
                1: fbStepLimitSwitch.Direction:=mcNegativeDirection;
                2: fbStepLimitSwitch.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepLimitSwitch.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepLimitSwitch.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepLimitSwitch.Done THEN
                fbFinishHoming.Execute:=TRUE;
                nHomingState:=nHomingState+1;
            END_IF
          4:
            IF fbFinishHoming.Done THEN
                bHomingInProgress:=FALSE;
                fbFinishHoming.Execute:=FALSE;
                bReadNcVelocities:=FALSE;
                nHomingState:=0;
            END_IF
        END_CASE
   3,4: //Home to bLimitBwd(3) or bLimitFwd(4) using two speeds
        CASE nHomingState OF
          0:
            fbStepLimitSwitchDetection.Execute:=FALSE;
            fbStepLimitSwitchDetection.LimitSwitchMode:=mcRisingEdge;
            fbStepLimitSwitchDetection.Velocity:=fbHomeReadNCVelocities.fVelocityToCam;
            CASE nHomeProcLocal OF
                3: fbStepLimitSwitchDetection.Direction:=mcNegativeDirection;
                4: fbStepLimitSwitchDetection.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepLimitSwitchDetection.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepLimitSwitchDetection.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepLimitSwitchDetection.Done THEN
                fbStepLimitSwitch.Execute:=FALSE;
                fbStepLimitSwitch.LimitSwitchMode:=mcFallingEdge;
                fbStepLimitSwitch.Velocity:=fbHomeReadNCVelocities.fVelocityFromCam;
                fbStepLimitSwitch.Setposition:=fHomePosition;
                CASE nHomeProcLocal OF
                    3: fbStepLimitSwitch.Direction:=mcNegativeDirection;
                    4: fbStepLimitSwitch.Direction:=mcPositiveDirection;
                END_CASE
                nHomingState:=nHomingState+1;
            END_IF
          4:
            fbStepLimitSwitch.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          5:
            IF fbStepLimitSwitch.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          6:
            IF fbStepLimitSwitch.Done THEN
                fbFinishHoming.Execute:=TRUE;
                nHomingState:=nHomingState+1;
            END_IF
          7:
            IF fbFinishHoming.Done THEN
                bHomingInProgress:=FALSE;
                fbFinishHoming.Execute:=FALSE;
                bReadNCVelocities:=FALSE;
                nHomingState:=0;
            END_IF
        END_CASE
    11,12: //Home to bHome Sensor moving in the negative(11) or positive(12) direction
        CASE nHomingState OF
          0:
            fbStepAbsoluteSwitch.Execute:=FALSE;
            fbStepAbsoluteSwitch.SwitchMode:=mcRisingEdge;
            fbStepAbsoluteSwitch.SetPosition:=fHomePosition;
            fbStepAbsoluteSwitch.Velocity:=fbHomeReadNCVelocities.fVelocityFromCam;
            CASE nHomeProcLocal OF
                11: fbStepAbsoluteSwitch.Direction:=mcNegativeDirection;
                12: fbStepAbsoluteSwitch.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepAbsoluteSwitch.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepAbsoluteSwitch.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepAbsoluteSwitch.Done THEN
                fbStepAbsoluteSwitch.Execute:=FALSE;
                fbFinishHoming.Execute:=TRUE;
                nHomingState:=nHomingState+1;
            END_IF
          4:
            IF fbFinishHoming.Done THEN
                bHomingInProgress:=FALSE;
                fbFinishHoming.Execute:=FALSE;
                bReadNCVelocities:=FALSE;
                nHomingState:=0;
            END_IF
        END_CASE
    13,14: //Home to bHomeSensor via bLimitBwd(13) or bLimitFwd(14)
        CASE nHomingState OF
          0:
            fbStepLimitSwitchDetection.Execute:=FALSE;
            fbStepLimitSwitchDetection.LimitSwitchMode:=mcRisingEdge;
            fbStepLimitSwitchDetection.Velocity:=fbHomeReadNCVelocities.fVelocityToCam;
            CASE nHomeProcLocal OF
                13: fbStepLimitSwitchDetection.Direction:=mcNegativeDirection;
                14: fbStepLimitSwitchDetection.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepLimitSwitchDetection.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepLimitSwitchDetection.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepLimitSwitchDetection.Done THEN
                fbStepLimitSwitchDetection.Execute:=FALSE;
                CASE nHomeProcLocal OF
                    13: nHomeProcLocal:=12;
                    14: nHomeProcLocal:=11;
                END_CASE
                nHomingState:=0;
            END_IF
        END_CASE
    21,22: //Home to index pulse of an encoder in the negative(21) or positive(22) direction
        CASE nHomingState OF
          0:
            fbStepReferencePulse.Execute:=FALSE;
            fbStepReferencePulse.SetPosition:=fHomePosition;
            fbStepReferencePulse.Velocity:=fbHomeReadNCVelocities.fVelocityFromCam;
            CASE nHomeProcLocal OF
                21: fbStepReferencePulse.Direction:=mcNegativeDirection;
                22: fbStepReferencePulse.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepReferencePulse.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepReferencePulse.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepReferencePulse.Done THEN
                fbStepReferencePulse.Execute:=FALSE;
                fbFinishHoming.Execute:=TRUE;
                nHomingState:=nHomingState+1;
            END_IF
          4:
            IF fbFinishHoming.Done THEN
                bHomingInProgress:=FALSE;
                fbFinishHoming.Execute:=FALSE;
                bReadNCVelocities:=FALSE;
                nHomingState:=0;
            END_IF
        END_CASE
    23,24: //Home to index pulse of an encoder via bLimitBwd(23) or bLimitFwd(24)
        CASE nHomingState OF
          0:
            fbStepLimitSwitchDetection.Execute:=FALSE;
            fbStepLimitSwitchDetection.LimitSwitchMode:=mcRisingEdge;
            fbStepLimitSwitchDetection.Velocity:=fbHomeReadNCVelocities.fVelocityToCam;
            CASE nHomeProcLocal OF
                23: fbStepLimitSwitchDetection.Direction:=mcNegativeDirection;
                24: fbStepLimitSwitchDetection.Direction:=mcPositiveDirection;
            END_CASE
            nHomingState:=nHomingState+1;
          1:
            fbStepLimitSwitchDetection.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2:
            IF fbStepLimitSwitchDetection.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3:
            IF fbStepLimitSwitchDetection.Done THEN
                fbStepLimitSwitchDetection.Execute:=FALSE;
                CASE nHomeProcLocal OF
                    23: nHomeProcLocal:=22;
                    24: nHomeProcLocal:=21;
                END_CASE
                nHomingState:=0;
            END_IF
        END_CASE
    90: //Set current position without moving
       CASE nHomingState OF
          0:
            fbHomeDirect.Execute:=FALSE;
            fbHomeDirect.SetPosition:=fHomePosition;
            nHomingState:=nHomingState+1;
          1:
            fbHomeDirect.Execute:=TRUE;
            nHomingState:=nHomingState+1;
          2: // Check that started
            IF fbHomeDirect.Busy THEN
                nHomingState:=nHomingState+1;
            END_IF
          3: // Check that finished
            IF fbHomeDirect.Done THEN
                fbHomeDirect.Execute:=FALSE;
                bHomingInProgress:=FALSE;
                bReadNCVelocities:=FALSE;
                nHomingState:=0;
            END_IF
        END_CASE
END_CASE
ELSE
    fbStepLimitSwitch.Execute:=FALSE;
    fbStepLimitSwitchDetection.Execute:=FALSE;
    fbStepAbsoluteSwitch.Execute:=FALSE;
    fbStepReferencePulse.Execute:=FALSE;
    fbHomeDirect.Execute:=FALSE;
    nHomingState:=0;
END_IF

//fbHomeReadNCVelocities
fbHomeReadNCVelocities.bExecute := bReadNCVelocities;
fbHomeReadNCVelocities.bReset := bReset;

//Advance Homing options
StOptions2.DisableDriveAccess:=TRUE;
StOptions4.DisableDriveAccess:=TRUE;
stOptions4.EnableLagErrorDetection:=TRUE;

//stLimitSwRef
IF fbStepLimitSwitch.Direction=mcPositiveDirection THEN
    stLimitSwRef.Level:=NOT(bLimitFwd);
ELSIF fbStepLimitSwitch.Direction=mcNegativeDirection THEN
    stLimitSwRef.Level:=NOT(bLimitBwd);
END_IF

//stLimitSwRef2
IF fbStepLimitSwitchDetection.Direction=mcPositiveDirection THEN
    stLimitSwRef2.Level:=NOT(bLimitFwd);
ELSIF fbStepLimitSwitchDetection.Direction=mcNegativeDirection THEN
    stLimitSwRef2.Level:=NOT(bLimitBwd);
END_IF

//fbStepLimitSwitch
fbStepLimitSwitch.LimitSwitchSignal := stLimitSwRef;
fbStepLimitSwitch.Options := StOptions4;

//fbStepLimitSwitchDetection
fbStepLimitSwitchDetection.LimitSwitchSignal := stLimitSwRef2;
fbStepLimitSwitchDetection.TimeLimit := tLimit;
fbStepLimitSwitchDetection.Options := StOptions4;

//stHomeSwRef
stHomeSwRef.Level := bHomeSensor;
stHomeSwRef.TouchProbe := PlcEvent;
stHomeSwRef.SignalSource := SignalSource_Default;

//fbStepAbsoluteSwitch
fbStepAbsoluteSwitch.ReferenceSignal := stHomeSwRef;
fbStepAbsoluteSwitch.TimeLimit := tLimit;
fbStepAbsoluteSwitch.PositiveLimitSwitch := NOT(bLimitFwd);
fbStepAbsoluteSwitch.NegativeLimitSwitch := NOT(bLimitBwd);
fbStepAbsoluteSwitch.Options := StOptions4;

//stIndexRef
stIndexRef.SignalSource := SignalSource_ZeroPulse;
stIndexRef.TouchProbe := TouchProbe1;

//fbStepReferencePulse
fbStepReferencePulse.ReferenceSignal := stIndexRef;
fbStepReferencePulse.TimeLimit := tLimit;
fbStepReferencePulse.Options := StOptions4;

//fbHomeDirect
fbHomeDirect.Options := StOptions2;

//fbFinishHoming
fbFinishHoming.Options := StOptions2;

//fbAbortHoming
fbAbortHoming.Options := StOptions2;

//Home aborted
IF fbStepLimitSwitch.CommandAborted OR fbStepLimitSwitchDetection.CommandAborted OR fbStepAbsoluteSwitch.CommandAborted OR fbStepReferencePulse.CommandAborted OR fbHomeDirect.CommandAborted THEN
    nHomingState := 0;
    bHomingInProgress := FALSE;
    bWarning := TRUE;
END_IF

//Homed status
bHomed := Axis.Status.Homed;

//Error handling
IF fbStepLimitSwitch.Error THEN
    bError := TRUE;
    nErrorId := fbStepLimitSwitch.ErrorID;
ELSIF fbStepLimitSwitchDetection.Error THEN
    bError := TRUE;
    nErrorId := fbStepLimitSwitchDetection.ErrorID;
ELSIF fbStepAbsoluteSwitch.Error THEN
    bError := TRUE;
    nErrorId := fbStepAbsoluteSwitch.ErrorID;
ELSIF fbStepReferencePulse.Error THEN
    bError := TRUE;
    nErrorId := fbStepReferencePulse.ErrorID;
ELSIF fbHomeDirect.Error THEN
    bError := TRUE;
    nErrorId := fbHomeDirect.ErrorID;
ELSIF fbAbortHoming.Error THEN
    bError := TRUE;
    nErrorId := fbAbortHoming.ErrorID;
ELSIF fbFinishHoming.Error THEN
    bError := TRUE;
    nErrorId := fbFinishHoming.ErrorID;
END_IF]]></ST>
    </Implementation>
    <LineIds Name="FB_Homing">
      <LineId Id="4310" Count="0" />
      <LineId Id="4287" Count="0" />
      <LineId Id="4289" Count="0" />
      <LineId Id="4307" Count="0" />
      <LineId Id="4340" Count="0" />
      <LineId Id="4343" Count="0" />
      <LineId Id="4354" Count="0" />
      <LineId Id="4357" Count="0" />
      <LineId Id="4284" Count="0" />
      <LineId Id="4358" Count="0" />
      <LineId Id="3852" Count="10" />
      <LineId Id="3864" Count="271" />
      <LineId Id="4290" Count="0" />
      <LineId Id="4136" Count="0" />
      <LineId Id="4139" Count="0" />
      <LineId Id="4291" Count="0" />
      <LineId Id="4141" Count="3" />
      <LineId Id="4292" Count="0" />
      <LineId Id="4145" Count="5" />
      <LineId Id="4298" Count="5" />
      <LineId Id="4295" Count="0" />
      <LineId Id="4304" Count="0" />
      <LineId Id="4294" Count="0" />
      <LineId Id="4154" Count="1" />
      <LineId Id="4297" Count="0" />
      <LineId Id="4296" Count="0" />
      <LineId Id="4168" Count="2" />
      <LineId Id="4305" Count="0" />
      <LineId Id="4171" Count="3" />
      <LineId Id="4335" Count="0" />
      <LineId Id="4177" Count="0" />
      <LineId Id="4336" Count="0" />
      <LineId Id="4179" Count="3" />
      <LineId Id="4337" Count="0" />
      <LineId Id="4183" Count="2" />
      <LineId Id="4339" Count="0" />
      <LineId Id="4338" Count="0" />
      <LineId Id="4189" Count="2" />
      <LineId Id="4361" Count="0" />
      <LineId Id="4192" Count="0" />
      <LineId Id="4359" Count="0" />
      <LineId Id="4363" Count="0" />
      <LineId Id="4362" Count="0" />
      <LineId Id="4360" Count="0" />
      <LineId Id="4365" Count="0" />
      <LineId Id="4364" Count="0" />
      <LineId Id="4206" Count="0" />
      <LineId Id="4367" Count="0" />
      <LineId Id="4374" Count="0" />
      <LineId Id="4368" Count="4" />
      <LineId Id="4376" Count="0" />
      <LineId Id="4373" Count="0" />
      <LineId Id="4366" Count="0" />
      <LineId Id="4375" Count="0" />
      <LineId Id="4208" Count="22" />
    </LineIds>
  </POU>
</TcPlcObject>