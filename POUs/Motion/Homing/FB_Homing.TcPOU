<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Homing" Id="{427b1d22-ef01-4bbb-ab89-ec8be67f3887}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Homing
VAR_IN_OUT
    Axis: Axis_Ref;
END_VAR
VAR_INPUT
    bExecute: BOOL;
    bLimitFwd: BOOL;
    bLimitBwd: BOOL;
    bHomeSensor: BOOL;
    bHomeReference: BOOL;
    eHomeSeq: E_HomingRoutines;
    fHomePosition: LREAL;
    fHomeFinishDistance: LREAL;
    stConfig: ST_AxisConfig;
END_VAR
VAR_OUTPUT
    bDone: BOOL;
    bBusy: BOOL;
    bCommandAborted: BOOL;
    bError: BOOL;
    nErrorId: UDINT;
END_VAR
VAR
    //Hardware Signals
    stLimitSwitchSignal: MC_Ref_Signal_Ref;
    stRefSwitchSignal: MC_Ref_Signal_Ref;
    stEncPulseSignal: MC_Ref_Signal_Ref;

    //Beckhoff homing function blocks
    fbStepLimitSwitch: MC_StepLimitSwitch;
    fbStepAbsoluteSwitch: MC_StepAbsoluteSwitch;
    fbStepReferencePulse: MC_StepReferencePulse;
    fbStepBlockLag: MC_StepBlockLagBased;
    fbHomeDirect: MC_HomeDirect;
    fbSetPos: MC_SetPosition;
    fbFinishHoming: MC_FinishHoming;
    fbAbortHoming: MC_AbortHoming;
    fbExecute: R_TRIG;
    fbTimerOnDelay: TON;
    fbHomeRefR_TRIG: R_TRIG;
    fbHomeRefF_TRIG: F_TRIG;

    //Homing parameters
    stDetectDirection: MC_Home_Direction;
    stDetectLimitDirection: MC_Home_Direction;
    stHomingParameter: MC_HomingParameter;
    stOptions: ST_Home_Options4;
    stOptions3: ST_Home_Options3;

    fSetHomePosition: LREAL;
    fHomeRefPosition: LREAL;
    fActPosition_Done: LREAL;

    fbVelocityToCam: MC_ReadParameter;
    fVelocityToCam: LREAL;
    fbVelocityFromCam: MC_ReadParameter;
    fVelocityFromCam: LREAL;
    fDetectionVelocity: LREAL;
    fDetectionAcceleration: LREAL;
    fDetectionDeceleration: LREAL;

    bDetectionFB_Execute: BOOL;
    bDetectionFB_Done: BOOL;
    bDetectionFB_Busy: BOOL;
    bDetectionFB_CommandAborted: BOOL;
    bDetectionFB_Error: BOOL;
    nDetectionFB_ErrorID: UDINT;
    iErrorId: UDINT;

    bSignalRisingEdge: BOOL;
    bSignalFallingEdge: BOOL;
    fRisingEdgePosition: LREAL;
    fFallingEdgePosition: LREAL;
    bDelay: BOOL;
    tDelayTime: TIME;

    //State machine
    eHomingState: (eWaitForRequest := 0, eCoarseDetection := 1, eMoveReverse := 2, eFineDetection := 3, eSetPos := 4, eFinishHoming := 5, eAbortHoming := 20);
    bHomeRefSensor: BOOL;
    bHomeRefLimit: BOOL;
    bHomeRefEncPulse: BOOL;
    bHomeBlock: BOOL;

    bTwoSpeedHoming:BOOL;
    bReversedDirection: BOOL;
    bFineDetection_Done: BOOL;
    bViaLimitCoarseDetect: BOOL;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[stLimitSwitchSignal.SignalSource := SignalSource_Default;
stLimitSwitchSignal.TouchProbe := PlcEvent;
stLimitSwitchSignal.Level := bHomeReference; //bHomeReference = NOT(bLimitFwd)/NOT(bLimitBwd)
stRefSwitchSignal.SignalSource := SignalSource_Default;
stRefSwitchSignal.TouchProbe := PlcEvent;
stRefSwitchSignal.Level := bHomeReference; //bHomeReference = bHomeSensor
stEncPulseSignal.SignalSource := SignalSource_ZeroPulse;
stEncPulseSignal.TouchProbe := TouchProbe1;

fbHomeRefR_TRIG(CLK := bHomeReference);

fbHomeRefF_TRIG(CLK := bHomeReference);

fbTimerOnDelay(IN := bDelay, PT := tDelayTime);
tDelayTime := T#1S0MS; //Delay Time 1sec befor switching the motor direction for mechanical saftey.

fDetectionAcceleration := 0; //If the value is 0, the standard acceleration from the axis configuration in the System Manager is used.
fDetectionDeceleration := 0; //If the value is 0, the standard deceleration from the axis configuration in the System Manager is used.

//Constantly read the NC for homing velocities so they are available when a homing is executed
fbVelocityToCam(
    Axis := Axis,
    Enable := TRUE,
    ParameterNumber := E_AxisParameters.AxisVelocityToCam,
    ReadMode := READMODE_CYCLIC);

fbVelocityFromCam(
    Axis:= Axis,
    Enable := TRUE,
    ParameterNumber := E_AxisParameters.AxisVelocityFromCam,
    ReadMode := READMODE_CYCLIC);

//Only write velocity if the function block has not errored
IF NOT fbVelocityToCam.Error THEN
    fVelocityToCam := fbVelocityToCam.Value;
END_IF

IF NOT fbVelocityFromCam.Error THEN
    fVelocityFromCam := fbVelocityFromCam.Value;
END_IF

 //Feeds function block errors through
IF fbVelocityToCam.Error THEN
    bError := TRUE;
    nErrorID := fbVelocityToCam.ErrorID;
ELSIF fbVelocityFromCam.Error THEN
    bError := TRUE;
    nErrorID := fbVelocityFromCam.ErrorID;
END_IF

//Common function blocks used for all routines
stOptions.DisableDriveAccess := stConfig.stHomingConfig.bDisableDriveAccess;
stOptions.EnableLagErrorDetection := stConfig.stHomingConfig.bEnableLagErrorDetection;

//For StepBlockLagDetection
stOptions3.DisableDriveAccess := stConfig.stHomingConfig.bDisableDriveAccess;
stOptions3.InstantLagReduction := stConfig.stHomingConfig.bInstantLagReduction;

fbSetPos.Options.ClearPositionLag := TRUE;
fbSetPos(
   Axis := Axis,
   Position := (fActPosition_Done - fHomeRefPosition) + fHomePosition);

fbFinishHoming.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbFinishHoming(
    Axis := Axis,
    Velocity := fVelocityFromCam,
    Acceleration := fDetectionAcceleration,
    Deceleration := fDetectionDeceleration,
    Parameter := stHomingParameter);

fbAbortHoming.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbAbortHoming(
    Axis := Axis,
    Parameter := stHomingParameter);

//ACTs contain function blocks custom to each individual routine for the detection stage
CASE eHomeSeq OF
    E_HomingRoutines.eHomeToLimit_Fwd,
    E_HomingRoutines.eHomeToLimit_Bwd:
        actHomeToLimit();

    E_HomingRoutines.eHomeToRef_Fwd,
    E_HomingRoutines.eHomeToRef_Bwd:
        actHomeToRef();

    E_HomingRoutines.eHomeToEncPulse_Fwd,
    E_HomingRoutines.eHomeToEncPulse_Bwd,
    E_HomingRoutines.eHomeToEncPulse_viaFwdLimit,
    E_HomingRoutines.eHomeToEncPulse_viaBwdLimit:
        actHomeToEncPulse();

    E_HomingRoutines.eHomeToBlock_Fwd,
    E_HomingRoutines.eHomeToBlock_Bwd:
        actHomeToBlock();

    E_HomingRoutines.eHomeDirect:
        actHomeDirect();
END_CASE

//State machine for Two Speed Homing
fbExecute(CLK := bExecute);
CASE eHomingState OF
    eWaitForRequest:
    IF NOT bExecute THEN
        bBusy := FALSE;
        bDone := FALSE;
        bCommandAborted := FALSE;
        bError := FALSE;
        bDelay := FALSE;
        bDetectionFB_Execute := FALSE;
        bTwoSpeedHoming := FALSE;
        bHomeRefSensor := FALSE;
        bHomeRefLimit := FALSE;
        bReversedDirection := FALSE;
        bSignalRisingEdge := FALSE;
        bSignalFallingEdge := FALSE;
        bFineDetection_Done := FALSE;
        nErrorID := 0;
        iErrorID := 0;

        fbHomeDirect.Execute := FALSE;
        fbStepAbsoluteSwitch.Execute := FALSE;
        fbStepLimitSwitch.Execute := FALSE;
        fbStepReferencePulse.Execute := FALSE;
        fbStepBlockLag.Execute := FALSE;
        fbSetPos.Execute := FALSE;
        fbFinishHoming.Execute := FALSE;
        fbAbortHoming.Execute := FALSE;
        END_IF

        IF fbExecute.Q AND NOT(eHomeSeq = E_HomingRoutines.eNoHoming)THEN
            IF eHomeSeq = E_HomingRoutines.eHomeDirect THEN
                fSetHomePosition := fHomePosition;
                bDetectionFB_Execute := TRUE;
                bBusy := bDetectionFB_Busy;
                bDone := bDetectionFB_Done;
                bCommandAborted := bDetectionFB_CommandAborted;
                bError :=  bDetectionFB_Error;
                nErrorId := nDetectionFB_ErrorID;
                IF NOT bDetectionFB_Busy AND bDetectionFB_Done THEN
                    bDetectionFB_Execute := FALSE;
                    eHomingState := eFinishHoming;
                END_IF
            ELSIF bTwoSpeedHoming THEN
                IF NOT bBusy AND bHomeReference THEN
                    IF bHomeRefSensor THEN
                        eHomingState := eMoveReverse;
                    ELSE
                        eHomingState := eFineDetection;
                    END_IF
                ELSIF NOT bBusy AND NOT bHomeReference THEN
                    eHomingState := eCoarseDetection;
                END_IF
            ELSE
                eHomingState := eFineDetection;
            END_IF
        END_IF

eCoarseDetection: //Detect the Home Reference with high speed (fVelocityToCam).
    bDelay := TRUE;
    bViaLimitCoarseDetect := TRUE;
    bReversedDirection := FALSE;
    fDetectionVelocity := fVelocityToCam;
    fSetHomePosition := Axis.NcToPlc.ActPos; //Set the Act. position as home position (no change until the home procedure is finished)
    IF fbTimerOnDelay.Q THEN
        bDetectionFB_Execute := TRUE;
        bBusy := bDetectionFB_Busy;
        IF NOT bDetectionFB_Busy AND bDetectionFB_Done THEN
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            IF bHomeRefSensor THEN //If the HomeToRef is called
                eHomingState := eMoveReverse;
            ELSE
                eHomingState := eFineDetection;
            END_IF
        ELSIF NOT bDetectionFB_Busy AND (bDetectionFB_Error OR bDetectionFB_CommandAborted) THEN
            iErrorID := nDetectionFB_ErrorID;
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eAbortHoming;
        END_IF
    END_IF

eMoveReverse: //Reversed Direction
    bDelay := TRUE;
    bReversedDirection := TRUE;
    fDetectionVelocity := fVelocityToCam;
    fSetHomePosition := Axis.NcToPlc.ActPos;
    IF fbTimerOnDelay.Q THEN
        bDetectionFB_Execute := TRUE;
        bBusy := bDetectionFB_Busy;
        IF NOT bDetectionFB_Busy AND bDetectionFB_Done THEN
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eFineDetection;
        ELSIF NOT bDetectionFB_Busy AND (bDetectionFB_Error OR bDetectionFB_CommandAborted) THEN
            iErrorID := nDetectionFB_ErrorID;
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eAbortHoming;
        END_IF
    END_IF

eFineDetection: //Detect the Home Reference with low speed (fVelocityFromCam).
    bDelay := TRUE;
    bViaLimitCoarseDetect := FALSE;
    bReversedDirection := FALSE;
    fDetectionVelocity := fVelocityFromCam;
    IF bHomeRefLimit OR bHomeRefSensor THEN
        fSetHomePosition := Axis.NcToPlc.ActPos;
        IF bFineDetection_Done THEN
            bFineDetection_Done := FALSE;
            eHomingState := eSetPos;
        END_IF
    ELSE
        fSetHomePosition := fHomePosition;
        IF bFineDetection_Done THEN
            bFineDetection_Done := FALSE;
            eHomingState := eFinishHoming;
        END_IF
    END_IF
    IF fbTimerOnDelay.Q THEN
        bDetectionFB_Execute := TRUE;
        bBusy := bDetectionFB_Busy;
        IF bHomeRefLimit OR bHomeRefSensor THEN
            IF bSignalRisingEdge AND fbHomeRefR_TRIG.Q THEN
                fRisingEdgePosition := Axis.NcToPlc.ActPos; //Read positon when Rising Edge of the home reference (Sensor/Limit)
                fHomeRefPosition := fRisingEdgePosition;
            ELSIF bSignalFallingEdge AND fbHomeRefF_TRIG.Q THEN
                fFallingEdgePosition := Axis.NcToPlc.ActPos; //Read positon when Falling Edge of the home reference (Sensor/Limit)
                fHomeRefPosition := fFallingEdgePosition;
            END_IF
        END_IF
        IF NOT bDetectionFB_Busy AND bDetectionFB_Done THEN
            fActPosition_Done := Axis.NcToPlc.ActPos;
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            bFineDetection_Done := TRUE;
        ELSIF NOT bDetectionFB_Busy AND (bDetectionFB_Error OR bDetectionFB_CommandAborted) THEN
            iErrorID := nDetectionFB_ErrorID;
            bDetectionFB_Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eAbortHoming;
        END_IF
    END_IF

eSetPos:
    fbSetPos.Execute := TRUE;
    IF NOT fbSetPos.Busy AND fbSetPos.Done THEN
        fbSetPos.Execute := FALSE;
        eHomingState := eFinishHoming;
    ELSIF NOT fbSetPos.Busy AND fbSetPos.Error THEN
        iErrorID := fbSetPos.ErrorID;
        fbSetPos.Execute := FALSE;
        eHomingState := eAbortHoming;
    END_IF

 eFinishHoming:
    bDelay := TRUE;
    IF fbTimerOnDelay.Q THEN
        fbFinishHoming.Distance := fHomeFinishDistance;
        fbFinishHoming.Execute := TRUE;
        IF NOT fbFinishHoming.Busy AND fbFinishHoming.Done THEN
            bBusy := FALSE;
            bDone := TRUE;
            fbFinishHoming.Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eWaitForRequest;
        ELSIF NOT fbFinishHoming.Busy AND (fbFinishHoming.Error OR fbFinishHoming.CommandAborted) THEN
            iErrorID := fbFinishHoming.ErrorID;
            fbFinishHoming.Execute := FALSE;
            bDelay := FALSE;
            eHomingState := eAbortHoming;
        END_IF
    END_IF

eAbortHoming:
    fbAbortHoming.Execute := TRUE;
    IF NOT fbAbortHoming.Busy AND fbAbortHoming.Done THEN
        bBusy := FALSE;
        IF iErrorId <> 0 THEN
            bError := TRUE;
            nErrorId := iErrorId;
        ELSE
            bCommandAborted := TRUE;
        END_IF
        fbAbortHoming.Execute := FALSE;
        bFineDetection_Done := FALSE;
        bDelay := FALSE;
        eHomingState := eWaitForRequest;
   ELSIF NOT fbAbortHoming.Busy AND fbAbortHoming.Error THEN
        bBusy := FALSE;
        bError := TRUE;
        nErrorID := fbAbortHoming.ErrorID;
        fbAbortHoming.Execute := FALSE;
        bFineDetection_Done := FALSE;
        bDelay := FALSE;
        eHomingState := eWaitForRequest;
   END_IF

 END_CASE

]]></ST>
    </Implementation>
    <Action Name="actHomeDirect" Id="{d23628f6-b24a-4bef-81d2-3d83fde8f1cd}">
      <Implementation>
        <ST><![CDATA[bTwoSpeedHoming := FALSE;

fbHomeDirect(
    Axis := Axis,
    Parameter := stHomingParameter,
    Execute := bDetectionFB_Execute,
    SetPosition := fSetHomePosition,
    Done => bDetectionFB_Done,
    Busy => bDetectionFB_Busy,
    CommandAborted => bDetectionFB_CommandAborted,
    Error => bDetectionFB_Error,
    ErrorID => nDetectionFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToBlock" Id="{7f7639d4-e566-498f-a828-fad9ed0e5d95}">
      <Implementation>
        <ST><![CDATA[
CASE eHomeSeq OF
    E_HomingRoutines.eHomeToBlock_Bwd:
        stDetectDirection := mcNegativeDirection;
    E_HomingRoutines.eHomeToBlock_Fwd:
        stDetectDirection := mcPositiveDirection;
END_CASE

bTwoSpeedHoming := FALSE;

fbStepBlockLag(
    Axis := Axis,
    Execute := bDetectionFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection,
    Velocity := fDetectionVelocity, //Maximum travel velocity (>0).
    DetectionVelocityLimit := stConfig.stHomingConfig.fDetectionVelocityLimit, //Velocity that must be fallen below for the time DetectionVelocityTime in order to detect driving against the fixed stop.
    DetectionVelocityTime := stConfig.stHomingConfig.tDetectionVelocityTime, //Time for detecting the velocity undershoot when driving against the fixed stop.
    TimeLimit :=  stConfig.stHomingConfig.tTimeLimit, //Exceeding this time leads to the search procedure being aborted.
    DistanceLimit := stConfig.stHomingConfig.fDistanceLimit, //Exceeding this distance in relation to the start position leads to the search procedure being aborted.
    TorqueLimit := stConfig.stHomingConfig.fTorqueLimit, //The motor torque is limited to this value (percentage of configured channel peak torque), in relation to the weight counterbalance that is possibly parameterized in the drive, in order to avoid mechanical damage.
    LagLimit := stConfig.stHomingConfig.fLagLimit, //Position lag value which, if exceeded, leads to detection of driving against the fixed stop.
    SetPosition:= fSetHomePosition,
    Options := stOptions3,
    Done => bDetectionFB_Done,
    Busy => bDetectionFB_Busy,
    CommandAborted => bDetectionFB_CommandAborted,
    Error => bDetectionFB_Error,
    ErrorID => nDetectionFB_ErrorID);

]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToEncPulse" Id="{48b338da-ce35-49b7-b692-c1dd5d495b98}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToEncPulse_Fwd:
        stDetectDirection := mcPositiveDirection;
        bTwoSpeedHoming := FALSE;
    E_HomingRoutines.eHomeToEncPulse_Bwd:
        stDetectDirection := mcNegativeDirection;
        bTwoSpeedHoming := FALSE;
    E_HomingRoutines.eHomeToEncPulse_viaFwdLimit:
        stDetectLimitDirection := mcPositiveDirection;
        stDetectDirection := mcNegativeDirection;
        bHomeReference := NOT(bLimitFwd);
        bTwoSpeedHoming := TRUE;
    E_HomingRoutines.eHomeToEncPulse_viaBwdLimit:
        stDetectLimitDirection := mcNegativeDirection;
        stDetectDirection := mcPositiveDirection;
        bHomeReference := NOT(bLimitBwd);
        bTwoSpeedHoming := TRUE;
END_CASE

IF bViaLimitCoarseDetect AND bTwoSpeedHoming THEN
   fbStepLimitSwitch.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
   fbStepLimitSwitch(
        Axis := Axis,
        Execute := bDetectionFB_Execute,
        Parameter := stHomingParameter,
        Direction := stDetectLimitDirection,
        LimitSwitchMode := stConfig.stHomingConfig.eLimitSwitchMode,
        LimitSwitchSignal := stLimitSwitchSignal,
        Velocity := fDetectionVelocity,
        Acceleration := fDetectionAcceleration,
        Deceleration := fDetectionDeceleration,
        SetPosition := fSetHomePosition,
        Options := stOptions,
        Done => bDetectionFB_Done,
        Busy => bDetectionFB_Busy,
        CommandAborted => bDetectionFB_CommandAborted,
        Error => bDetectionFB_Error,
        ErrorID => nDetectionFB_ErrorID);

ELSIF NOT bViaLimitCoarseDetect THEN
    fbStepReferencePulse.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
    fbStepReferencePulse(
        Axis := Axis,
        Execute := bDetectionFB_Execute,
        Parameter := stHomingParameter,
        Direction := stDetectDirection,
        ReferenceSignal := stEncPulseSignal,
        Velocity := fDetectionVelocity,
        Options := stOptions,
        SetPosition := fSetHomePosition,
        Done => bDetectionFB_Done,
        Busy => bDetectionFB_Busy,
        CommandAborted => bDetectionFB_CommandAborted,
        Error => bDetectionFB_Error,
        ErrorID => nDetectionFB_ErrorID);
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToLimit" Id="{3859e05e-8699-4334-9196-1315e94174a0}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToLimit_Fwd:
    stDetectDirection:= mcPositiveDirection;
    bHomeReference := NOT(bLimitFwd); //The hardware signal is the Fwd Limit switch

    E_HomingRoutines.eHomeToLimit_Bwd:
    stDetectDirection:= mcNegativeDirection;
    bHomeReference := NOT(bLimitBwd); //The hardware signal is the Bwd Limit switch
END_CASE

bTwoSpeedHoming := TRUE;
bHomeRefLimit := TRUE;

//It is used to record the home position at Rising or Falling Edge
IF stConfig.stHomingConfig.eLimitSwitchMode = mcRisingEdge THEN
    bSignalRisingEdge := TRUE;
    bSignalFallingEdge := FALSE;
ELSIF stConfig.stHomingConfig.eLimitSwitchMode = mcFallingEdge THEN
    bSignalRisingEdge := FALSE;
    bSignalFallingEdge := TRUE;
END_IF

fbStepLimitSwitch.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbStepLimitSwitch(
    Axis := Axis,
    Execute := bDetectionFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection,
    LimitSwitchMode := stConfig.stHomingConfig.eLimitSwitchMode,
    LimitSwitchSignal := stLimitSwitchSignal,
    Velocity := fDetectionVelocity,
    Acceleration := fDetectionAcceleration,
    Deceleration := fDetectionDeceleration,
    SetPosition := fSetHomePosition,
    Options := stOptions,
    Done => bDetectionFB_Done,
    Busy => bDetectionFB_Busy,
    CommandAborted => bDetectionFB_CommandAborted,
    Error => bDetectionFB_Error,
    ErrorID => nDetectionFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToRef" Id="{1a440701-e71d-439b-9045-d08d31798b28}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToRef_Fwd:
    IF NOT bReversedDirection THEN
        stDetectDirection := mcPositiveDirection;
    ELSE
        stDetectDirection := mcNegativeDirection;
    END_IF

    E_HomingRoutines.eHomeToRef_Bwd:
    IF NOT bReversedDirection THEN
        stDetectDirection := mcNegativeDirection;
    ELSE
        stDetectDirection := mcPositiveDirection;
    END_IF
END_CASE

bHomeReference := bHomeSensor; //Hardware home sensor (Reference siganl for homing)
bTwoSpeedHoming := TRUE;
bHomeRefSensor := TRUE;

IF NOT bReversedDirection THEN
    fbStepAbsoluteSwitch.SwitchMode := stConfig.stHomingConfig.eRefSwitchMode;
ELSE
    fbStepAbsoluteSwitch.SwitchMode := stConfig.stHomingConfig.eRefSwitchModeReversed;
END_IF

 //It is used to record the home position at Rising or Falling Edge
IF stConfig.stHomingConfig.eRefSwitchMode = mcRisingEdge THEN
    bSignalRisingEdge := TRUE;
    bSignalFallingEdge := FALSE;
ELSIF stConfig.stHomingConfig.eRefSwitchMode = mcFallingEdge THEN
    bSignalRisingEdge := FALSE;
    bSignalFallingEdge := TRUE;
END_IF

fbStepAbsoluteSwitch(
    Axis := Axis,
    Execute := bDetectionFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection, //MC_Home_Direction(mcPositiveDirection, mcNegativeDirection)
    ReferenceSignal := stRefSwitchSignal,
    Velocity := fDetectionVelocity,
    Acceleration := fDetectionAcceleration, //If the value is 0, the standard acceleration from the axis configuration in the System Manager is used.
    Deceleration := fDetectionDeceleration, //If the value is 0, the standard deceleration from the axis configuration in the System Manager is used.
    SetPosition := fSetHomePosition,
    PositiveLimitSwitch := NOT(bLimitFwd),
    NegativeLimitSwitch := NOT(bLimitBwd),
    Options := stOptions,
    Done => bDetectionFB_Done,
    Busy => bDetectionFB_Busy,
    CommandAborted => bDetectionFB_CommandAborted,
    Error => bDetectionFB_Error,
    ErrorID => nDetectionFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>