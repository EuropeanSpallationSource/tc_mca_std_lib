<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Homing" Id="{427b1d22-ef01-4bbb-ab89-ec8be67f3887}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Homing
VAR_IN_OUT
    Axis: Axis_Ref;
END_VAR
VAR_INPUT
    bExecute: BOOL;
    bLimitFwd: BOOL;
    bLimitBwd: BOOL;
    bHomeSensor: BOOL;
    eHomeSeq: E_HomingRoutines;
    fHomePosition: LREAL;
    fHomeFinishDistance: LREAL;
    stConfig: ST_AxisConfig;
END_VAR
VAR_OUTPUT
    bDone: BOOL;
    bBusy: BOOL;
    bCommandAborted: BOOL;
    bError: BOOL;
    nErrorId: UDINT;
END_VAR
VAR
    bHWSignalForHoming: BOOL;

    //Hardware Signals
    stLimitSwitchSignal: MC_Ref_Signal_Ref;
    stRefSwitchSignal: MC_Ref_Signal_Ref;
    stEncPulseSignal: MC_Ref_Signal_Ref;

    //Beckhoff homing function blocks
    fbStepLimitSwitch: MC_StepLimitSwitch;
    fbStepAbsoluteSwitch: MC_StepAbsoluteSwitch;
    fbStepReferencePulse: MC_StepReferencePulse;
    fbStepBlockLag: MC_StepBlockLagBased;
    fbHomeDirect: MC_HomeDirect;
    fbSetPos: MC_SetPosition;
    fbFinishHoming: MC_FinishHoming;
    fbAbortHoming: MC_AbortHoming;
    fbExecute: R_TRIG;
    fbTimerOnDelay: TON;
    fbHWHomeSignalRTrig: R_TRIG;
    fbHWHomeSignalFTrig: F_TRIG;

    //Homing parameters
    stDetectDirection: MC_Home_Direction;
    stDetectLimitDirection: MC_Home_Direction;
    stHomingParameter: MC_HomingParameter;
    stOptions: ST_Home_Options4;
    stOptions3: ST_Home_Options3;

    fSetHomePosition: LREAL;
    fHomeRefPosition: LREAL;
    fActPosition_Done: LREAL;

    fbVelocityToCam: MC_ReadParameter;
    fVelocityToCam: LREAL;
    fbVelocityFromCam: MC_ReadParameter;
    fVelocityFromCam: LREAL;
    fDetectionVelocity: LREAL;
    fDetectionAcceleration: LREAL;
    fDetectionDeceleration: LREAL;

    //Signals for the Beckhoff homing function blocks
    bLocalHomingFB_Execute: BOOL;
    bLocalHomingFB_Done: BOOL;
    bLocalHomingFB_Busy: BOOL;
    bLocalHomingFB_CommandAborted: BOOL;
    bLocalHomingFB_Error: BOOL;
    nLocalHomingFB_ErrorID: UDINT;

    bRisingEdgeDetectionOn: BOOL;
    bFallingEdgeDetectionOn: BOOL;
    fRisingEdgePosition: LREAL;
    fFallingEdgePosition: LREAL;
    bDelay: BOOL;

    //State machine
    eHomingState: (eWaitForRequest := 0, eCoarseDetection := 1, eMoveReverse := 2, eFineDetection := 3, eSetPos := 4, eFinishHoming := 5, eAbortHoming := 20);
    bHomingToHomeSensor: BOOL;
    bHomingToLimitSwitch: BOOL;

    bTwoSpeedHoming:BOOL;
    bReversedDirection: BOOL;
    bFineDetectionDone: BOOL;
    bViaLimitCoarseDetect: BOOL;
END_VAR

VAR CONSTANT
        tDELAY_TIME: TIME := T#1S0MS; //Delay Time 1sec befor switching the motor direction for mechanical saftey
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[stLimitSwitchSignal.SignalSource := SignalSource_Default;
stLimitSwitchSignal.TouchProbe := PlcEvent;
stLimitSwitchSignal.Level := bHWSignalForHoming; //bHomeReference = NOT(bLimitFwd)/NOT(bLimitBwd)
stRefSwitchSignal.SignalSource := SignalSource_Default;
stRefSwitchSignal.TouchProbe := PlcEvent;
stRefSwitchSignal.Level := bHWSignalForHoming; //bHomeReference = bHomeSensor
stEncPulseSignal.SignalSource := SignalSource_ZeroPulse;
stEncPulseSignal.TouchProbe := TouchProbe1;

fbHWHomeSignalRTrig(CLK := bHWSignalForHoming);

fbHWHomeSignalFTrig(CLK := bHWSignalForHoming);

fbTimerOnDelay(IN := bDelay, PT := tDELAY_TIME);

fDetectionAcceleration := stConfig.fDefaultAcc;
fDetectionDeceleration := stConfig.fDefaultDec;

//Constantly read the NC for homing velocities so they are available when a homing is executed
fbVelocityToCam(
    Axis := Axis,
    Enable := TRUE,
    ParameterNumber := E_AxisParameters.AxisVelocityToCam,
    ReadMode := READMODE_CYCLIC);

fbVelocityFromCam(
    Axis:= Axis,
    Enable := TRUE,
    ParameterNumber := E_AxisParameters.AxisVelocityFromCam,
    ReadMode := READMODE_CYCLIC);

//Only write velocity if the function block has not errored
IF NOT fbVelocityToCam.Error THEN
    fVelocityToCam := fbVelocityToCam.Value;
END_IF

IF NOT fbVelocityFromCam.Error THEN
    fVelocityFromCam := fbVelocityFromCam.Value;
END_IF

 //Feeds function block errors through
IF fbVelocityToCam.Error THEN
    bError := TRUE;
    nErrorID := fbVelocityToCam.ErrorID;
ELSIF fbVelocityFromCam.Error THEN
    bError := TRUE;
    nErrorID := fbVelocityFromCam.ErrorID;
END_IF

//Common function blocks used for all routines
stOptions.DisableDriveAccess := stConfig.stHomingConfig.bDisableDriveAccess;
stOptions.EnableLagErrorDetection := stConfig.stHomingConfig.bEnableLagErrorDetection;

//For StepBlockLagDetection
stOptions3.DisableDriveAccess := stConfig.stHomingConfig.bDisableDriveAccess;
stOptions3.InstantLagReduction := stConfig.stHomingConfig.bInstantLagReduction;

fbSetPos.Options.ClearPositionLag := TRUE;
fbSetPos(
   Axis := Axis,
   Position := (fActPosition_Done - fHomeRefPosition) + fHomePosition);

fbFinishHoming.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbFinishHoming(
    Axis := Axis,
    Velocity := fVelocityFromCam,
    Acceleration := fDetectionAcceleration,
    Deceleration := fDetectionDeceleration,
    Parameter := stHomingParameter);

fbAbortHoming.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbAbortHoming(
    Axis := Axis,
    Parameter := stHomingParameter);

//ACTs contain function blocks custom to each individual routine for the detection stage
CASE eHomeSeq OF
    E_HomingRoutines.eHomeToLimit_Fwd,
    E_HomingRoutines.eHomeToLimit_Bwd:
        actHomeToLimit();

    E_HomingRoutines.eHomeToRef_Fwd,
    E_HomingRoutines.eHomeToRef_Bwd:
        actHomeToSensor();

    E_HomingRoutines.eHomeToEncPulse_Fwd,
    E_HomingRoutines.eHomeToEncPulse_Bwd,
    E_HomingRoutines.eHomeToEncPulse_viaFwdLimit,
    E_HomingRoutines.eHomeToEncPulse_viaBwdLimit:
        actHomeToEncPulse();

    E_HomingRoutines.eHomeToBlock_Fwd,
    E_HomingRoutines.eHomeToBlock_Bwd:
        actHomeToBlock();

    E_HomingRoutines.eHomeDirect:
        actHomeDirect();
END_CASE

//State machine for Two Speed Homing
fbExecute(CLK := bExecute);
CASE eHomingState OF
    eWaitForRequest:
        IF NOT bExecute THEN
            bBusy := FALSE;
            bDone := FALSE;
            bCommandAborted := FALSE;
            bError := FALSE;
            bDelay := FALSE;
            bLocalHomingFB_Execute := FALSE;
            bTwoSpeedHoming := FALSE;
            bHomingToHomeSensor := FALSE;
            bHomingToLimitSwitch := FALSE;
            bReversedDirection := FALSE;
            bRisingEdgeDetectionOn := FALSE;
            bFallingEdgeDetectionOn := FALSE;
            bFineDetectionDone := FALSE;
            nErrorID := 0;

            fbHomeDirect.Execute := FALSE;
            fbStepAbsoluteSwitch.Execute := FALSE;
            fbStepLimitSwitch.Execute := FALSE;
            fbStepReferencePulse.Execute := FALSE;
            fbStepBlockLag.Execute := FALSE;
            fbSetPos.Execute := FALSE;
            fbFinishHoming.Execute := FALSE;
            fbAbortHoming.Execute := FALSE;
            END_IF

            IF fbExecute.Q AND NOT(eHomeSeq = E_HomingRoutines.eNoHoming)THEN
                IF eHomeSeq = E_HomingRoutines.eHomeDirect THEN
                    fSetHomePosition := fHomePosition;
                    bLocalHomingFB_Execute := TRUE;
                    bBusy := bLocalHomingFB_Busy;
                    bDone := bLocalHomingFB_Done;
                    bCommandAborted := bLocalHomingFB_CommandAborted;
                    bError :=  bLocalHomingFB_Error;
                    nErrorId := nLocalHomingFB_ErrorID;
                    IF NOT bLocalHomingFB_Busy AND bLocalHomingFB_Done THEN
                        bLocalHomingFB_Execute := FALSE;
                        eHomingState := eFinishHoming;
                    END_IF
                ELSIF bTwoSpeedHoming THEN
                    IF NOT bBusy AND bHWSignalForHoming THEN
                        IF bHomingToHomeSensor THEN
                            eHomingState := eMoveReverse;
                        ELSE
                            eHomingState := eFineDetection;
                        END_IF
                    ELSIF NOT bBusy AND NOT bHWSignalForHoming THEN
                        eHomingState := eCoarseDetection;
                    END_IF
                ELSE
                    eHomingState := eFineDetection;
                END_IF
            END_IF

    eCoarseDetection: //Detect the Home Reference with high speed (fVelocityToCam).
        bDelay := TRUE;
        bViaLimitCoarseDetect := TRUE;
        bReversedDirection := FALSE;
        fDetectionVelocity := fVelocityToCam;
        fSetHomePosition := Axis.NcToPlc.ActPos; //Set the Act. position as home position (no change until the home procedure is finished)
        IF fbTimerOnDelay.Q THEN
            bLocalHomingFB_Execute := TRUE;
            bBusy := bLocalHomingFB_Busy;
            IF NOT bLocalHomingFB_Busy AND bLocalHomingFB_Done THEN
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                IF bHomingToHomeSensor THEN
                    eHomingState := eMoveReverse;
                ELSE
                    eHomingState := eFineDetection;
                END_IF
            ELSIF NOT bLocalHomingFB_Busy AND (bLocalHomingFB_Error OR bLocalHomingFB_CommandAborted) THEN
                nErrorID := nLocalHomingFB_ErrorID;
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eAbortHoming;
            END_IF
        END_IF

    eMoveReverse: //After detecting the reference sensor reversed direction
        bDelay := TRUE;
        bReversedDirection := TRUE;
        fDetectionVelocity := fVelocityToCam;
        fSetHomePosition := Axis.NcToPlc.ActPos;
        IF fbTimerOnDelay.Q THEN
            bLocalHomingFB_Execute := TRUE;
            bBusy := bLocalHomingFB_Busy;
            IF NOT bLocalHomingFB_Busy AND bLocalHomingFB_Done THEN
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eFineDetection;
            ELSIF NOT bLocalHomingFB_Busy AND (bLocalHomingFB_Error OR bLocalHomingFB_CommandAborted) THEN
                nErrorID := nLocalHomingFB_ErrorID;
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eAbortHoming;
            END_IF
        END_IF

    eFineDetection: //Detect the Home Reference with low speed (fVelocityFromCam).
        bDelay := TRUE;
        bViaLimitCoarseDetect := FALSE;
        bReversedDirection := FALSE;
        fDetectionVelocity := fVelocityFromCam;
        IF bHomingToLimitSwitch OR bHomingToHomeSensor THEN
            fSetHomePosition := Axis.NcToPlc.ActPos;
            IF bFineDetectionDone THEN
                bFineDetectionDone := FALSE;
                eHomingState := eSetPos;
            END_IF
        ELSE
            fSetHomePosition := fHomePosition;
            IF bFineDetectionDone THEN
                bFineDetectionDone := FALSE;
                eHomingState := eFinishHoming;
            END_IF
        END_IF
        IF fbTimerOnDelay.Q THEN
            bLocalHomingFB_Execute := TRUE;
            bBusy := bLocalHomingFB_Busy;
            IF bHomingToLimitSwitch OR bHomingToHomeSensor THEN
                IF bRisingEdgeDetectionOn AND fbHWHomeSignalRTrig.Q THEN
                    fRisingEdgePosition := Axis.NcToPlc.ActPos; //Read positon when Rising Edge of the home reference (Sensor/Limit)
                    fHomeRefPosition := fRisingEdgePosition;
                ELSIF bFallingEdgeDetectionOn AND fbHWHomeSignalFTrig.Q THEN
                    fFallingEdgePosition := Axis.NcToPlc.ActPos; //Read positon when Falling Edge of the home reference (Sensor/Limit)
                    fHomeRefPosition := fFallingEdgePosition;
                END_IF
            END_IF
            IF NOT bLocalHomingFB_Busy AND bLocalHomingFB_Done THEN
                fActPosition_Done := Axis.NcToPlc.ActPos;
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                bFineDetectionDone := TRUE;
            ELSIF NOT bLocalHomingFB_Busy AND (bLocalHomingFB_Error OR bLocalHomingFB_CommandAborted) THEN
                nErrorID := nLocalHomingFB_ErrorID;
                bLocalHomingFB_Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eAbortHoming;
            END_IF
        END_IF

    eSetPos:
        fbSetPos.Execute := TRUE;
        IF NOT fbSetPos.Busy AND fbSetPos.Done THEN
            fbSetPos.Execute := FALSE;
            eHomingState := eFinishHoming;
        ELSIF NOT fbSetPos.Busy AND fbSetPos.Error THEN
            nErrorID := fbSetPos.ErrorID;
            fbSetPos.Execute := FALSE;
            eHomingState := eAbortHoming;
        END_IF

    //Check handling of busy
    eFinishHoming:
        bDelay := TRUE;
        IF fbTimerOnDelay.Q THEN
            fbFinishHoming.Distance := fHomeFinishDistance;
            fbFinishHoming.Execute := TRUE;
            IF NOT fbFinishHoming.Busy AND fbFinishHoming.Done THEN
                bBusy := FALSE;
                bDone := TRUE;
                fbFinishHoming.Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eWaitForRequest;
            ELSIF NOT fbFinishHoming.Busy AND (fbFinishHoming.Error OR fbFinishHoming.CommandAborted) THEN
                nErrorID := fbFinishHoming.ErrorID;
                fbFinishHoming.Execute := FALSE;
                bDelay := FALSE;
                eHomingState := eAbortHoming;
            END_IF
        END_IF

    //Check handling of busy
    eAbortHoming:
        fbAbortHoming.Execute := TRUE;
        IF NOT fbAbortHoming.Busy AND fbAbortHoming.Done THEN
            bBusy := FALSE;
            //delete when iErrorID changes to nErrorID
            bError := bLocalHomingFB_Error;
            nErrorId := nLocalHomingFB_ErrorID;
            bCommandAborted := TRUE;
            fbAbortHoming.Execute := FALSE;
            bFineDetectionDone := FALSE;
            bDelay := FALSE;
            eHomingState := eWaitForRequest;
        ELSIF NOT fbAbortHoming.Busy AND fbAbortHoming.Error THEN
            bBusy := FALSE;
            bError := TRUE;
            nErrorID := fbAbortHoming.ErrorID;
            fbAbortHoming.Execute := FALSE;
            bFineDetectionDone := FALSE;
            bDelay := FALSE;
            eHomingState := eWaitForRequest;
        END_IF

 END_CASE

]]></ST>
    </Implementation>
    <Action Name="actHomeDirect" Id="{d23628f6-b24a-4bef-81d2-3d83fde8f1cd}">
      <Implementation>
        <ST><![CDATA[bTwoSpeedHoming := FALSE;

fbHomeDirect(
    Axis := Axis,
    Parameter := stHomingParameter,
    Execute := bLocalHomingFB_Execute,
    SetPosition := fSetHomePosition,
    Done => bLocalHomingFB_Done,
    Busy => bLocalHomingFB_Busy,
    CommandAborted => bLocalHomingFB_CommandAborted,
    Error => bLocalHomingFB_Error,
    ErrorID => nLocalHomingFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToBlock" Id="{7f7639d4-e566-498f-a828-fad9ed0e5d95}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToBlock_Bwd:
        stDetectDirection := mcNegativeDirection;
    E_HomingRoutines.eHomeToBlock_Fwd:
        stDetectDirection := mcPositiveDirection;
END_CASE

bTwoSpeedHoming := FALSE;

fbStepBlockLag(
    Axis := Axis,
    Execute := bLocalHomingFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection,
    Velocity := fDetectionVelocity, //Maximum travel velocity (>0).
    DetectionVelocityLimit := stConfig.stHomingConfig.fDetectionVelocityLimit, //Velocity that must be fallen below for the time DetectionVelocityTime in order to detect driving against the fixed stop.
    DetectionVelocityTime := stConfig.stHomingConfig.tDetectionVelocityTime, //Time for detecting the velocity undershoot when driving against the fixed stop.
    TimeLimit :=  stConfig.stHomingConfig.tTimeLimit, //Exceeding this time leads to the search procedure being aborted.
    DistanceLimit := stConfig.stHomingConfig.fDistanceLimit, //Exceeding this distance in relation to the start position leads to the search procedure being aborted.
    TorqueLimit := stConfig.stHomingConfig.fTorqueLimit, //The motor torque is limited to this value (percentage of configured channel peak torque), in relation to the weight counterbalance that is possibly parameterized in the drive, in order to avoid mechanical damage.
    LagLimit := stConfig.stHomingConfig.fLagLimit, //Position lag value which, if exceeded, leads to detection of driving against the fixed stop.
    SetPosition:= fSetHomePosition,
    Options := stOptions3,
    Done => bLocalHomingFB_Done,
    Busy => bLocalHomingFB_Busy,
    CommandAborted => bLocalHomingFB_CommandAborted,
    Error => bLocalHomingFB_Error,
    ErrorID => nLocalHomingFB_ErrorID);

]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToEncPulse" Id="{48b338da-ce35-49b7-b692-c1dd5d495b98}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToEncPulse_Fwd:
        stDetectDirection := mcPositiveDirection;
        bTwoSpeedHoming := FALSE;
    E_HomingRoutines.eHomeToEncPulse_Bwd:
        stDetectDirection := mcNegativeDirection;
        bTwoSpeedHoming := FALSE;
    E_HomingRoutines.eHomeToEncPulse_viaFwdLimit:
        stDetectLimitDirection := mcPositiveDirection;
        stDetectDirection := mcNegativeDirection;
        bHWSignalForHoming := NOT(bLimitFwd);
        bTwoSpeedHoming := TRUE;
    E_HomingRoutines.eHomeToEncPulse_viaBwdLimit:
        stDetectLimitDirection := mcNegativeDirection;
        stDetectDirection := mcPositiveDirection;
        bHWSignalForHoming := NOT(bLimitBwd);
        bTwoSpeedHoming := TRUE;
END_CASE

IF bViaLimitCoarseDetect AND bTwoSpeedHoming THEN
   fbStepLimitSwitch.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
   fbStepLimitSwitch(
        Axis := Axis,
        Execute := bLocalHomingFB_Execute,
        Parameter := stHomingParameter,
        Direction := stDetectLimitDirection,
        LimitSwitchMode := stConfig.stHomingConfig.eLimitSwitchMode,
        LimitSwitchSignal := stLimitSwitchSignal,
        Velocity := fDetectionVelocity,
        Acceleration := fDetectionAcceleration,
        Deceleration := fDetectionDeceleration,
        SetPosition := fSetHomePosition, //This fSetPosition is not used to set the Home position. Needs to be there so FB works correctly.
        Options := stOptions,
        Done => bLocalHomingFB_Done,
        Busy => bLocalHomingFB_Busy,
        CommandAborted => bLocalHomingFB_CommandAborted,
        Error => bLocalHomingFB_Error,
        ErrorID => nLocalHomingFB_ErrorID);

ELSIF NOT bViaLimitCoarseDetect THEN
    fbStepReferencePulse.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
    fbStepReferencePulse(
        Axis := Axis,
        Execute := bLocalHomingFB_Execute,
        Parameter := stHomingParameter,
        Direction := stDetectDirection,
        ReferenceSignal := stEncPulseSignal,
        Velocity := fDetectionVelocity,
        Options := stOptions,
        SetPosition := fSetHomePosition,
        Done => bLocalHomingFB_Done,
        Busy => bLocalHomingFB_Busy,
        CommandAborted => bLocalHomingFB_CommandAborted,
        Error => bLocalHomingFB_Error,
        ErrorID => nLocalHomingFB_ErrorID);
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToLimit" Id="{3859e05e-8699-4334-9196-1315e94174a0}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToLimit_Fwd:
    stDetectDirection:= mcPositiveDirection;
    bHWSignalForHoming := NOT(bLimitFwd); //The hardware signal is the Fwd Limit switch

    E_HomingRoutines.eHomeToLimit_Bwd:
    stDetectDirection:= mcNegativeDirection;
    bHWSignalForHoming := NOT(bLimitBwd); //The hardware signal is the Bwd Limit switch
END_CASE

bTwoSpeedHoming := TRUE;
bHomingToLimitSwitch := TRUE;

IF stConfig.stHomingConfig.eLimitSwitchMode = mcRisingEdge THEN
    bRisingEdgeDetectionOn := TRUE;
    bFallingEdgeDetectionOn := FALSE;
ELSIF stConfig.stHomingConfig.eLimitSwitchMode = mcFallingEdge THEN
    bRisingEdgeDetectionOn := FALSE;
    bFallingEdgeDetectionOn := TRUE;
END_IF

fbStepLimitSwitch.Options.DisableDriveAccess := stOptions.DisableDriveAccess;
fbStepLimitSwitch(
    Axis := Axis,
    Execute := bLocalHomingFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection,
    LimitSwitchMode := stConfig.stHomingConfig.eLimitSwitchMode,
    LimitSwitchSignal := stLimitSwitchSignal,
    Velocity := fDetectionVelocity,
    Acceleration := fDetectionAcceleration,
    Deceleration := fDetectionDeceleration,
    SetPosition := fSetHomePosition,
    Options := stOptions,
    Done => bLocalHomingFB_Done,
    Busy => bLocalHomingFB_Busy,
    CommandAborted => bLocalHomingFB_CommandAborted,
    Error => bLocalHomingFB_Error,
    ErrorID => nLocalHomingFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="actHomeToSensor" Id="{1a440701-e71d-439b-9045-d08d31798b28}">
      <Implementation>
        <ST><![CDATA[CASE eHomeSeq OF
    E_HomingRoutines.eHomeToRef_Fwd:
    IF NOT bReversedDirection THEN
        stDetectDirection := mcPositiveDirection;
    ELSE
        stDetectDirection := mcNegativeDirection;
    END_IF

    E_HomingRoutines.eHomeToRef_Bwd:
    IF NOT bReversedDirection THEN
        stDetectDirection := mcNegativeDirection;
    ELSE
        stDetectDirection := mcPositiveDirection;
    END_IF
END_CASE

bHWSignalForHoming := bHomeSensor; //Hardware home sensor (Reference siganl for homing)
bTwoSpeedHoming := TRUE;
bHomingToHomeSensor := TRUE;

IF NOT bReversedDirection THEN
    fbStepAbsoluteSwitch.SwitchMode := stConfig.stHomingConfig.eRefSwitchMode;
ELSE
    fbStepAbsoluteSwitch.SwitchMode := stConfig.stHomingConfig.eRefSwitchModeReversed;
END_IF

IF stConfig.stHomingConfig.eRefSwitchMode = mcRisingEdge THEN
    bRisingEdgeDetectionOn := TRUE;
    bFallingEdgeDetectionOn := FALSE;
ELSIF stConfig.stHomingConfig.eRefSwitchMode = mcFallingEdge THEN
    bRisingEdgeDetectionOn := FALSE;
    bFallingEdgeDetectionOn := TRUE;
END_IF

fbStepAbsoluteSwitch(
    Axis := Axis,
    Execute := bLocalHomingFB_Execute,
    Parameter := stHomingParameter,
    Direction := stDetectDirection,
    ReferenceSignal := stRefSwitchSignal,
    Velocity := fDetectionVelocity,
    Acceleration := fDetectionAcceleration,
    Deceleration := fDetectionDeceleration,
    SetPosition := fSetHomePosition,
    PositiveLimitSwitch := NOT(bLimitFwd),
    NegativeLimitSwitch := NOT(bLimitBwd),
    Options := stOptions,
    Done => bLocalHomingFB_Done,
    Busy => bLocalHomingFB_Busy,
    CommandAborted => bLocalHomingFB_CommandAborted,
    Error => bLocalHomingFB_Error,
    ErrorID => nLocalHomingFB_ErrorID);
]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>