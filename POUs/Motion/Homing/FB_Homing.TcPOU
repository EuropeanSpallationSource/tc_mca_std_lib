<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="FB_Homing" Id="{9504e6ea-30a8-43fd-9cc1-4227ce39269a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Homing
VAR_INPUT
    bExecute: BOOL;
    bReset: BOOL;
    bStop: BOOL;
    nHomeProc: UINT;
    bLimitBwd: BOOL;
    bLimitFwd: BOOL;
    bEncLatch: BOOL;
    bHomeSensor: BOOL;
    fHomePosition: LREAL;
END_VAR
VAR_IN_OUT
    Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
    bHomed:BOOL;
    bError: BOOL;
    nErrorId: UDINT;
END_VAR
VAR
    En: BOOL:=TRUE;
    fbHomeToSwitch: FB_HomeToSwitch;
    fbHomeDirect: FB_HomeDirect; //Only used for direct homing (set of position)
    fbMoveVelocity:MC_MoveVelocity;
    fbHomePrepare:FB_HomePrepare;
    fbHomeFinish:FB_HomeFinish;
    fbExecuteRiseEdge: R_TRIG;
    nHomingState:INT:=0;
    bExecuteHomeToSwitch:BOOL:=FALSE;
    bExecuteMoveVelocity:BOOL:=FALSE;
    bExecutePrepare: BOOL:=FALSE;
    bExecuteFinish: BOOL:=FALSE;
    bExecuteHomeDirect: BOOL;
    nHomeProcLocal: UINT;  //Ensure that nCmdData is not changed during sequence
    bSequenceReady:BOOL:=TRUE;
    bRestoreNCDataNeeded: BOOL:=FALSE;
    fbRTrigLatch: R_TRIG;
    bLatched: BOOL;
    fbSetLatch :SR;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[

IF bReset THEN
    bError:=FALSE;
    nErrorId:=0;
END_IF

// Reset when bExecute is low
IF NOT bExecute THEN
  nHomingState:=0;
  bSequenceReady:=TRUE;
  bExecuteHomeToSwitch:=FALSE;
  bExecuteHomeDirect:=FALSE;
  bExecuteMoveVelocity:=FALSE;
  bExecutePrepare:=FALSE;
  bExecuteFinish:=FALSE;
END_IF

//Reset at rinsing edge of bExecute
fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  nHomeProcLocal:=nHomeProc; //Ensure that nHomeProc is not changed during sequence (nCmdData will only be read at a rising edge of bExecute)
  bSequenceReady:=FALSE;
  bExecutePrepare:=TRUE;
  bRestoreNCDataNeeded:=FALSE;
  //Check if valid nCmdDataLocal
  CASE nHomeProcLocal OF
    1:
    2:
    3:
    4:
    5:
    6:
    15:
    ELSE //nCmdData not valid
      bError:=TRUE;
      nErrorId:=16#4FFF;
  END_CASE
END_IF

//############# Prepare for homing (Read from NC and reset homed flag)
fbHomePrepare(
  En:=En,
  bExecute:=bExecutePrepare AND NOT bError, // Not needed for sequence 15 (set position only, no movement))
  bReset:=bReset,
  Axis:=Axis,
);

/////LAtch signal of enconder///////
fbRTrigLatch(CLK:=bEncLatch, Q=> );
//fbSetLatch(SET1:=,
//  RESET:=(fbRTrigLatch.Q AND bLatched),
//  Q1=>bLatched );

CASE nHomeProc OF

   1: // Home to low limit switch
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
            END_IF
          2: // Wait for fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=NOT bLimitBwd;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;

   2: // Home to high limit switch
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
            END_IF
          2: // Wait for fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=NOT bLimitFwd;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;

   3: // Home on bHomeSensor via bLimitBwd
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
            END_IF
          2: // Wait for fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=bHomeSensor;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;
    4:  // Home on bHomeSensor via bLimitFwd
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbExecuteToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
            END_IF
          2: // Wait for fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=bHomeSensor;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // Restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;
    5: // Home on Enc Latch via LimtBwd
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbHomeToSwitch
            bHomed:=FALSE;
            //bEncLatch:=TRUE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
             // bEncLatch:=TRUE;
            END_IF
          2: // Wait for Latch signal
            fbSetLatch(SET1:= NOT bLimitBwd AND NOT fbSetLatch.Q1 ,
                RESET:=fbRTrigLatch.Q ,
                Q1=>bLatched );
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=fbSetLatch.Q1;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;

    6: // Home on Enc Latch via bLimitFwd
       CASE nHomingState OF
          0:
            bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
            IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
              bRestoreNCDataNeeded:=TRUE;
              IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
                nHomingState:=2;  //Standing on limit switch go direct to state 2
              END_IF
            END_IF
          1: // wait for reach low limit then trigger fbHomeToSwitch
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
            bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
            IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
              nHomingState:=2;
            END_IF
          2: // Wait for Latch signal
            fbSetLatch(SET1:= NOT bLimitFwd AND NOT fbSetLatch.Q1 ,
                RESET:=fbRTrigLatch.Q ,
                Q1=>bLatched );
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;
            bExecuteHomeToSwitch:=TRUE;
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;
            fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
            fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed
            fbHomeToSwitch.bCamSensor:=bLatched;
            IF fbHomeToSwitch.bDone THEN
              nHomingState:=3;
              bExecuteFinish:=TRUE;
              fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
              fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
            END_IF;
          3: // Restore softlimit enable
            bHomed:=FALSE;
            bSequenceReady:=FALSE;
            IF fbHomeFinish.bDone THEN
              bRestoreNCDataNeeded:=FALSE;
              bSequenceReady:=TRUE;
              nHomingState:=0;
              bHomed:=Axis.Status.Homed;
            END_IF;
       END_CASE;

   15: //Set current position (simplest homing sequence)
     bExecuteHomeDirect:=bExecute;
     bHomed:=Axis.Status.Homed;
     IF fbHomeDirect.bDone THEN  //Homing ready
       bExecuteHomeDirect:=FALSE;
       bSequenceReady:=TRUE;
     END_IF

ELSE
  fbHomeToSwitch.bCamSensor:=FALSE;
  bHomed:=Axis.Status.Homed;
END_CASE;

// Main homing block
fbHomeToSwitch(
    bExecute:=bExecuteHomeToSwitch AND bExecute AND NOT bError AND NOT bExecuteHomeDirect AND NOT bExecuteMoveVelocity,
    bReset:=bReset,
    fHomePosition:=fHomePosition,
    Axis:=Axis
);

// Approach limit switch (error if MC_Home is used)
fbMoveVelocity(
    Execute:= bExecuteMoveVelocity AND bExecute AND NOT bError AND NOT bExecuteHomeToSwitch AND NOT bExecuteHomeDirect,
    Axis:=Axis
);

// No sequence, just set position value (nCmdDataLocal=15). Can not run if fbHomeToSwitch is executed
fbHomeDirect(
    bExecute:=bExecuteHomeDirect AND bExecute AND NOT bError  AND NOT bExecuteHomeToSwitch AND NOT bExecuteMoveVelocity,
    bReset:=bReset,
    fHomePosition:=fHomePosition,
    Axis:=Axis
);


//############# Finish homing

IF NOT bExecute AND bRestoreNCDataNeeded THEN  //If homing is aborted restore is needed
    bExecuteFinish:=TRUE;
    IF fbHomeFinish.bDone THEN
      bExecuteFinish:=FALSE;
      bRestoreNCDataNeeded:=FALSE;
    END_IF
END_IF

fbHomeFinish(
  En:=En,
  bExecute:=bExecuteFinish,
  bReset:=bReset,
  Axis:=Axis,
);

// Error handling
IF NOT bError THEN
  IF fbHomeToSwitch.bError THEN
    bError:=fbHomeToSwitch.bError;
    nErrorId:=fbHomeToSwitch.nErrorId;
  ELSIF fbHomeDirect.bError THEN
    bError:=fbHomeDirect.bError;
    nErrorId:=fbHomeDirect.nErrorId;
  ELSIF fbMoveVelocity.Error THEN
    bError:=fbMoveVelocity.Error;
    nErrorId:=fbMoveVelocity.ErrorId;
  END_IF;
END_IF

(*// Done and busy bit
bDone:=bSequenceReady AND bExecute;
bBusy:=NOT bSequenceReady;
*)


bHomed:=Axis.Status.Homed;]]></ST>
    </Implementation>
    <LineIds Name="FB_Homing">
      <LineId Id="737" Count="0" />
      <LineId Id="221" Count="29" />
      <LineId Id="666" Count="0" />
      <LineId Id="716" Count="0" />
      <LineId Id="251" Count="12" />
      <LineId Id="178" Count="0" />
      <LineId Id="719" Count="0" />
      <LineId Id="718" Count="0" />
      <LineId Id="721" Count="3" />
      <LineId Id="179" Count="0" />
      <LineId Id="264" Count="195" />
      <LineId Id="567" Count="14" />
      <LineId Id="730" Count="0" />
      <LineId Id="582" Count="5" />
      <LineId Id="717" Count="0" />
      <LineId Id="588" Count="1" />
      <LineId Id="735" Count="1" />
      <LineId Id="734" Count="0" />
      <LineId Id="590" Count="23" />
      <LineId Id="460" Count="0" />
      <LineId Id="714" Count="0" />
      <LineId Id="667" Count="22" />
      <LineId Id="732" Count="1" />
      <LineId Id="731" Count="0" />
      <LineId Id="690" Count="23" />
      <LineId Id="566" Count="0" />
      <LineId Id="715" Count="0" />
      <LineId Id="461" Count="11" />
      <LineId Id="60" Count="0" />
      <LineId Id="473" Count="55" />
      <LineId Id="9" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="36" Count="1" />
    </LineIds>
  </POU>
</TcPlcObject>