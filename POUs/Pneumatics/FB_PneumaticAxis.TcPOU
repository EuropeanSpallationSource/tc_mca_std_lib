<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_PneumaticAxis" Id="{f0822a38-f63b-03f0-165a-8d38581f4fae}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PneumaticAxis

VAR_IN_OUT
    stPneumaticAxisStruct: ST_PneumaticAxisStruct;
END_VAR
VAR
    fbTimerExtend: TON; //Timing the extraction of the cylinder
    fbTimerRetract: TON; //Timing the retraction of the cylinder
    fbTimerAirPressureErrorLow: TON; //Timer to check the fluctuation of the low air pressure value
    fbTimerAirPressureErrorHigh: TON; //Timer to check the fluctuation of the high air pressure value
    fbTrigRisingEdgePermit: R_TRIG; //Rising edge detection for Permit signal
    fbTrigExtend: R_TRIG; //Rising edge detection to Extend cylinder
    fbTrigRetract: R_TRIG; //Rising edge detection to Retract cylinder
    fbTrigExtendManual: R_TRIG; //Rising edge detection for manual push button
    fbTrigRetractManual: R_TRIG; //Rising edge detection for manual push button
    bStateChange: BOOL := FALSE; //State of the cylinder changed from extend to retract and vice versa
    bStartExtendPLC: BOOL; //Variable to extend cylinder from PLC
    bStartRetractPLC: BOOL; //Variable to retract cylinder from PLC
    bStartExtendManual: BOOL; //Variable to extend cylinder with momentary push button
    bStartRetractManual: BOOL; //Variable to retract cylinder with momentary push button

    bStartInitDelay: BOOL := FALSE;
    tInitializeTimer: TON;
    bInitialized: BOOL := FALSE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[tInitializeTimer(IN := bStartInitDelay, PT := T#1S);

IF tInitializeTimer.Q THEN
    bStartInitDelay := FALSE;
    bInitialized := TRUE;
END_IF

IF bInitialized THEN
    mRun();

    CASE stPneumaticAxisStruct.ePneumaticAxisMode OF

        E_PneumaticMode.eSingleSolenoidControl:
        mSingleSolenoid();

        E_PneumaticMode.eError:
        mSingleSolenoidError();

        E_PneumaticMode.eReset:
        mReset();

    END_CASE
END_IF




















]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{5454029e-f817-018f-32fe-52a7c013d503}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
    bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
    bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bStartInitDelay := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckEndSwitchBwdStatus" Id="{fde97b3f-ebc0-087e-124e-79f9c467bc30}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchBwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn
   AND NOT bStateChange
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckEndSwitchFwdStatus" Id="{2421d0d3-9422-0ef2-10bf-967b1b7d731a}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchFwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn
   AND bStateChange
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForAirPressureError" Id="{02975cbe-1049-025d-3e6b-ceb11cb4a2a0}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForAirPressureError : BOOL
VAR
    bAirPressureoutOfRangeError : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbTimerAirPressureErrorLow(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);
fbTimerAirPressureErrorHigh(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);

//Check if the air pressure value is too low for longer than defined time
IF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled < stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue  THEN
    fbTimerAirPressureErrorLow.IN := TRUE;
    IF fbTimerAirPressureErrorLow.Q THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        bAirPressureoutOfRangeError := TRUE;
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorLow;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF

//Check if the air pressure value is too high for longer than defined time
ELSIF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled > stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue  THEN
    fbTimerAirPressureErrorHigh.IN := TRUE;
    IF fbTimerAirPressureErrorHigh.Q THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        bAirPressureoutOfRangeError := TRUE;
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorHigh;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF

//If the air pressure value is in range, no errors
ELSIF (stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled >= stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue
      AND stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled <= stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue) THEN
    fbTimerAirPressureErrorLow.IN := FALSE;
    fbTimerAirPressureErrorHigh.IN := FALSE;
    bAirPressureoutOfRangeError := FALSE;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForMovingError" Id="{c3d6d062-4852-0e9f-18de-b8a77172336a}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForMovingError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF the command to extract is given, but the cylinder hasn't moved from the bEndSwitchBwd
IF fbTimerExtend.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingExtract;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//If the command to extract has timed out
IF fbTimerExtend.Q
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eExtractTimedOut;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//IF the command to retract has been given, but the cylinder hasn't moved from bEndSwitchFwd
IF fbTimerRetract.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingRetract;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//If the command to retract has timed out
IF fbTimerRetract.Q
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eRetractTimedOut;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfInterlockSignal" Id="{cc7fcaed-155e-0884-115d-338b746a2dd3}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfInterlockSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eInterlockOn;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfPermitSignal" Id="{a6169d52-c0e0-0319-04a8-3ea0650a4765}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfPermitSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT stPneumaticAxisStruct.stPneumaticAxisConfig.bPSSPneumaticAxisShutter THEN
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit := FALSE;
ELSIF NOT stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoPSSPermit;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReset" Id="{bc07a74c-56da-0ae1-1243-896a7db698c7}">
      <Declaration><![CDATA[METHOD PUBLIC mReset

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Reset all the error messages
//Set the operating mode to Single Solenoid Control
fbTrigRisingEdgePermit(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bReset);
IF fbTrigRisingEdgePermit.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    stPneumaticAxisStruct.stPneumaticAxisControl.bReset := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRun" Id="{b4d070a0-7784-0558-17c5-7f5403c420ef}">
      <Declaration><![CDATA[METHOD PUBLIC mRun
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the current status of the end position switches, and permit and intelock signals
mSetInputStatuses();

//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
mSetAllowedTravelTime();

//Get the value of the air pressure in mb
stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled := mScaledPressureValue(nRawValue :=  stPneumaticAxisStruct.stPneumaticAxisInputs.nAirPressureValueRaw, fRawHigh := 30518, fRawLow :=0, fScaledHigh := 10, fScaledLow := 0 );

//Check if air pressure is in range
mCheckForAirPressureError();

//Reset Error
mReset();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="mScaledPressureValue" Id="{3012bd32-5e56-08e5-357d-6a59fe398239}">
      <Declaration><![CDATA[METHOD PUBLIC mScaledPressureValue : REAL
VAR_INPUT
    nRawValue: INT; //Raw value from the Terminal
    fRawHigh: REAL; //Highest value for the Raw value
    fRawLow: REAL; //Lowest value for the Raw value
    fScaledHigh: REAL; //Highest value for the Scaled value
    fScaledLow: REAL; //Lowest value for the Scaled value
END_VAR
VAR
    rGradient: REAL; //Internal variable to calculate gradient of the slope
    rOffset: REAL; //Internal variable to calculate the offset value
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rGradient:= (fScaledHigh - fScaledLow)/(fRawHigh - fRawLow);
rOffset:= fScaledHigh - rGradient * fRawHigh;
mScaledPressureValue:= rGradient * nRawValue + rOffset;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetAllowedTravelTime" Id="{ee25c044-23c7-095b-0652-d0275aeaa21a}">
      <Declaration><![CDATA[METHOD PUBLIC mSetAllowedTravelTime

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
fbTimerExtend.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToExtend)*1000;
fbTimerRetract.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToRetract)*1000;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetInputStatuses" Id="{85a914cc-13e6-05a5-383f-5d3b917db237}">
      <Declaration><![CDATA[METHOD PUBLIC mSetInputStatuses
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the inputs of limit switches to bExtracted and bRetracted states of the pneumatic cylinders
//Check if cylinder is moving: extending or retracting
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchBwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchFwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bSolenoidActive := stPneumaticAxisStruct.stPneumaticAxisInputs.bSolenoidActive;
stPneumaticAxisStruct.stPneumaticAxisStatus.bPSSPermitOK := stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit;
stPneumaticAxisStruct.stPneumaticAxisStatus.bInterlocked := stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoid" Id="{7947fd9c-1dec-078f-0fa8-640a9c506249}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoid

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Check if Permit signal is ON
mCheckStatusOfPermitSignal();

//Check if Interlock signal is ON
mCheckStatusOfInterlockSignal();

//Starting the timing of extraction movement
fbTimerExtend(IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending);
stPneumaticAxisStruct.stPneumaticAxisStatus.nTimeElapsedExtend := TIME_TO_INT(fbTimerExtend.ET);

fbTrigExtend(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bExtend);
IF fbTrigExtend.Q THEN
   bStartExtendPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigExtendManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual);
IF fbTrigExtendManual.Q THEN
   bStartExtendManual := TRUE;
END_IF

//Starting the extraction movement
IF (bStartExtendPLC OR bStartExtendManual) THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := TRUE;
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
       AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := TRUE;
    END_IF
    //If the command to retract is given while the cylinder is extracting
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
          AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        IF (bStartRetractPLC OR bStartRetractManual) THEN
            stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
            bStartExtendPLC := FALSE;
            bStartExtendManual := FALSE;
        END_IF
    END_IF
END_IF

// Extraction of the cylinder finished, reset timer
IF (bStartExtendPLC OR bStartExtendManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    bStateChange := TRUE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
    bStartExtendPLC := FALSE;
    bStartExtendManual := FALSE;
END_IF

//Check if LimitSwitchBwd signal is ON
mCheckEndSwitchFwdStatus();

//Starting the retraction movement and retraction timing
fbTimerRetract (IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting);
stPneumaticAxisStruct.stPneumaticAxisStatus.nTimeElapsedRetract := TIME_TO_INT(fbTimerRetract.ET);

fbTrigRetract(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bRetract);
IF fbTrigRetract.Q THEN
   bStartRetractPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigRetractManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual);
IF fbTrigRetractManual.Q THEN
   bStartRetractManual := TRUE;
END_IF

IF (bStartRetractPLC OR bStartRetractManual) THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
       AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
    END_IF
END_IF

// Retraction of the cylinder finished, reset timer
IF  (bStartRetractPLC OR bStartRetractManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    bStateChange := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
    bStartRetractPLC := FALSE;
    bStartRetractManual := FALSE;
END_IF

mCheckForMovingError();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoidError" Id="{60e07ee6-93c1-0a35-3946-686c9080e0f9}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoidError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE  stPneumaticAxisStruct.ePneumaticAxisErrors OF

    E_PneumaticAxisErrors.eNoError:
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;

    E_PneumaticAxisErrors.eAirPressureErrorLow:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO LOW';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eAirPressureErrorHigh:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO HIGH';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eExtractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eRetractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingExtract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingRetract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM END SWITCH BWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM LIMIT SWITCH FWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoPSSPermit:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO PERMIT SIGNAL';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eInterlockOn:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: INTERLOCK SIGNAL ON';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

END_CASE

stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>