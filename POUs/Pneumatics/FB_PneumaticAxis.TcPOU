<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_PneumaticAxis" Id="{0ba43c5d-0b1b-4802-81a2-a56c90343a83}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PneumaticAxis

VAR_IN_OUT
    stPneumaticAxisStruct: ST_PneumaticAxisStruct;
END_VAR
VAR
    fbTimerExtend: TON; //Timing the extraction of the cylinder
    fbTimerRetract: TON; //Timing the retraction of the cylinder
    fbTimerAirPressureErrorLow: TON; //Timer to check the fluctuation of the low air pressure value
    fbTimerAirPressureErrorHigh: TON; //Timer to check the fluctuation of the high air pressure value
    fbTrigRisingEdgePermit: R_TRIG; //Rising edge detection for Permit signal
    fbTrigExtend: R_TRIG; //Rising edge detection to Extend cylinder
    fbTrigRetract: R_TRIG; //Rising edge detection to Retract cylinder
    fbTrigExtendManual: R_TRIG; //Rising edge detection for manual push button
    fbTrigRetractManual: R_TRIG; //Rising edge detection for manual push button
    bStateChange: BOOL := FALSE; //State of the cylinder changed from extend to retract and vice versa
    bStartExtendPLC: BOOL; //Variable to extend cylinder from PLC
    bStartRetractPLC: BOOL; //Variable to retract cylinder from PLC
    bStartExtendManual: BOOL; //Variable to extend cylinder with momentary push button
    bStartRetractManual: BOOL; //Variable to retract cylinder with momentary push button

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[mRun();

CASE stPneumaticAxisStruct.ePneumaticAxisMode OF

    E_PneumaticMode.eSingleSolenoidControl:
    mSingleSolenoid();

    E_PneumaticMode.eError:
    mSingleSolenoidError();

    E_PneumaticMode.eReset:
    mReset();

END_CASE




















]]></ST>
    </Implementation>
    <Method Name="mCheckEndSwitchBwdStatus" Id="{06cf6d5a-16e0-438c-85b6-51ad0c4cc91d}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchBwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bStateChange AND NOT stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn THEN
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd;
         stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
        END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckEndSwitchFwdStatus" Id="{df07c6b6-6902-4500-8747-be2fd3560637}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchFwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bStateChange AND stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn THEN
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
        END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForAirPressureError" Id="{f9b14adb-ed69-49af-a993-e6e5d49fd78d}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForAirPressureError : BOOL
VAR
    bAirPressureoutOfRangeError : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbTimerAirPressureErrorLow(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);
fbTimerAirPressureErrorHigh(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);

//Check if the air pressure value is too low for longer than defined time
IF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled < stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue  THEN
    fbTimerAirPressureErrorLow.IN := TRUE;
    IF fbTimerAirPressureErrorLow.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    bAirPressureoutOfRangeError := TRUE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorLow;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF
//Check if the air pressure value is too high for longer than defined time
ELSIF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled > stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue  THEN
    fbTimerAirPressureErrorHigh.IN := TRUE;
    IF fbTimerAirPressureErrorHigh.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    bAirPressureoutOfRangeError := TRUE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorHigh;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF
//If the air pressure value is in range, no errors
ELSIF (stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled >= stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue AND stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled <= stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue) THEN
    fbTimerAirPressureErrorLow.IN := FALSE;
    fbTimerAirPressureErrorHigh.IN := FALSE;
    bAirPressureoutOfRangeError := FALSE;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForMovingError" Id="{38f0c607-b572-456d-8f26-90f3b9594647}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForMovingError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF the command to extract is given, but the cylinder hasn't moved from the bEndSwitchBwd
    IF  fbTimerExtend.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
             stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
             stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingExtract;
             stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF

//If the command to extract has timed out
    IF  fbTimerExtend.Q AND (NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended) THEN
            stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
            stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eExtractTimedOut;
            stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF

//IF the command to retract has been given, but the cylinder hasn't moved from bEndSwitchFwd
        IF  fbTimerRetract.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
            stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
            stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingRetract;
            stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
        END_IF

//If the command to retract has timed out
        IF  fbTimerRetract.Q AND (NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted) THEN
            stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
            stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eRetractTimedOut;
            stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
        END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfInterlockSignal" Id="{3759dc88-e87e-4376-86a5-1bdfbc4158fe}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfInterlockSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
            stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
            stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eInterlockOn;
            stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfPermitSignal" Id="{5d308b37-3dc0-48eb-9350-16f4ad213248}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfPermitSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT stPneumaticAxisStruct.stPneumaticAxisConfig.bPSSPneumaticAxisShutter THEN
       stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit := TRUE;
ELSIF NOT stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
           stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
           stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoPSSPermit;
           stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
    END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReset" Id="{4721b129-abfa-4113-85bb-a13eb59dedea}">
      <Declaration><![CDATA[METHOD PUBLIC mReset

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Reset all the error messages
//Set the operating mode to Single Solenoid Control
fbTrigRisingEdgePermit(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bReset);
IF fbTrigRisingEdgePermit.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    stPneumaticAxisStruct.stPneumaticAxisControl.bReset := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRun" Id="{4ff666c5-8aa4-4eaa-803d-5700cbef55c2}">
      <Declaration><![CDATA[METHOD PUBLIC mRun
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the current status of the end position switches, and permit and intelock signals
mSetInputStatuses();

//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
mSetAllowedTravelTime();

//Get the value of the air pressure in mb
stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled := mScaledPressureValue(nRawValue :=  stPneumaticAxisStruct.stPneumaticAxisInputs.nAirPressureValueRaw, fRawHigh := 30518, fRawLow :=0, fScaledHigh := 10, fScaledLow := 0 );

//Check if Permit signal is ON
mCheckStatusOfPermitSignal();

//Check if Interlock signal is ON
mCheckStatusOfInterlockSignal();

//Check if air pressure is in range
mCheckForAirPressureError();

//Reset Error
mReset();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mScaledPressureValue" Id="{cb34ab57-a376-4317-a285-420d3612f714}">
      <Declaration><![CDATA[METHOD PUBLIC mScaledPressureValue : REAL
VAR_INPUT
    nRawValue: INT; //Raw value from the Terminal
    fRawHigh: REAL; //Highest value for the Raw value
    fRawLow: REAL; //Lowest value for the Raw value
    fScaledHigh: REAL; //Highest value for the Scaled value
    fScaledLow: REAL; //Lowest value for the Scaled value
END_VAR
VAR
    rGradient: REAL; //Internal variable to calculate gradient of the slope
    rOffset: REAL; //Internal variable to calculate the offset value
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rGradient:= (fScaledHigh - fScaledLow)/(fRawHigh - fRawLow);
rOffset:= fScaledHigh - rGradient * fRawHigh;
mScaledPressureValue:= rGradient * nRawValue + rOffset;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetAllowedTravelTime" Id="{1503d621-dee7-42a9-91aa-f87392c1d737}">
      <Declaration><![CDATA[METHOD PUBLIC mSetAllowedTravelTime

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
fbTimerExtend.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToExtend)*1000;
fbTimerRetract.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToRetract)*1000;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetInputStatuses" Id="{7e8f02a9-eec6-4e57-afc7-756f5956c71a}">
      <Declaration><![CDATA[METHOD PUBLIC mSetInputStatuses
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the inputs of limit switches to bExtracted and bRetracted states of the pneumatic cylinders
//Check if cylinder is moving: extending or retracting
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchBwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchFwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bSolenoidActive := stPneumaticAxisStruct.stPneumaticAxisInputs.bSolenoidActive;
stPneumaticAxisStruct.stPneumaticAxisStatus.bPSSPermitOK := stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit;
stPneumaticAxisStruct.stPneumaticAxisStatus.bInterlocked := stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoid" Id="{8261ebf9-e0cc-4c7d-9850-4c5e547b1764}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoid

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Starting the timing of extraction movement
fbTimerExtend(IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending);

fbTrigExtend(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bExtend);
IF fbTrigExtend.Q THEN
   bStartExtendPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigExtendManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual);
IF fbTrigExtendManual.Q THEN
   bStartExtendManual := TRUE;
END_IF

//Starting the extraction movement
IF (bStartExtendPLC OR bStartExtendManual) THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := TRUE;
        IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := TRUE;
        END_IF
//If the command to retract is given while the cylinder is extracting
IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        IF (bStartRetractPLC OR bStartRetractManual) THEN
            stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
            bStartExtendPLC := FALSE;
            bStartExtendManual := FALSE;
        END_IF
    END_IF
END_IF

// Extraction of the cylinder finished, reset timer
IF (bStartExtendPLC OR bStartExtendManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
        bStateChange := TRUE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
        bStartExtendPLC := FALSE;
        bStartExtendManual := FALSE;
END_IF

//Check if LimitSwitchBwd signal is ON
mCheckEndSwitchFwdStatus();

//Starting the retraction movement and retraction timing
fbTimerRetract (IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting);

fbTrigRetract(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bRetract);
IF fbTrigRetract.Q THEN
   bStartRetractPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigRetractManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual);
IF fbTrigRetractManual.Q THEN
   bStartRetractManual := TRUE;
END_IF

IF (bStartRetractPLC OR bStartRetractManual) THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
        END_IF
END_IF

// Retraction of the cylinder finished, reset timer
IF  (bStartRetractPLC OR bStartRetractManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        bStateChange := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
        bStartRetractPLC := FALSE;
        bStartRetractManual := FALSE;
END_IF
//Check if LimitSwitchFwd signal is ON
mCheckEndSwitchBwdStatus();

mCheckForMovingError();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoidError" Id="{9bc66883-6ee1-41c7-aebe-403858ab95d4}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoidError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE  stPneumaticAxisStruct.ePneumaticAxisErrors OF

    E_PneumaticAxisErrors.eNoError:
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;

    E_PneumaticAxisErrors.eAirPressureErrorLow:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO LOW';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eAirPressureErrorHigh:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO HIGH';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eExtractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eRetractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingExtract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingRetract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM END SWITCH BWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM LIMIT SWITCH FWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoPSSPermit:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO PERMIT SIGNAL';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eInterlockOn:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: INTERLOCK SIGNAL ON';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

END_CASE

stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>