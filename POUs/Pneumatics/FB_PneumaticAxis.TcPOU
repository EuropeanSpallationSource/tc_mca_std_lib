<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_PneumaticAxis" Id="{0ba43c5d-0b1b-4802-81a2-a56c90343a83}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PneumaticAxis

VAR_IN_OUT
    stPneumaticAxisStruct: ST_PneumaticAxisStruct;
END_VAR
VAR
    fbTimerExtend: TON; //Timing the extraction of the cylinder
    fbTimerRetract: TON; //Timing the retraction of the cylinder
    fbTimerAirPressureErrorLow: TON; //Timer to check the fluctuation of the low air pressure value
    fbTimerAirPressureErrorHigh: TON; //Timer to check the fluctuation of the high air pressure value
    fbTimerAirPressureNoErrorLow: TON; //Timer to check the fluctuation of the low air pressure value
    fbTimerAirPressureNoErrorHigh: TON; //Timer to check the fluctuation of the high air pressure value
    fbTrigRisingEdgePermit: R_TRIG; //Rising edge detection for Permit signal
    fbTrigExtend: R_TRIG; //Rising edge detection to Extend cylinder
    fbTrigRetract: R_TRIG; //Rising edge detection to Retract cylinder
    fbTrigExtendManual: R_TRIG; //Rising edge detection for manual push button
    fbTrigRetractManual: R_TRIG; //Rising edge detection for manual push button
    bStateChange: BOOL := FALSE; //State of the cylinder changed from extend to retract and vice versa
    bStartExtendPLC: BOOL; //Variable to extend cylinder from PLC
    bStartRetractPLC: BOOL; //Variable to retract cylinder from PLC
    bStartExtendManual: BOOL; //Variable to extend cylinder with momentary push button
    bStartRetractManual: BOOL; //Variable to retract cylinder with momentary push button
    bInterlockedExtended: BOOL := FALSE;
    bInterlockedRetracted: BOOL := FALSE;
    bNoPSSPermitError: BOOL := FALSE;
    bStartInitDelay: BOOL := FALSE;
    tInitializeTimer: TON;
    bInitialized: BOOL := FALSE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[tInitializeTimer(IN := bStartInitDelay, PT := T#1S);

IF tInitializeTimer.Q THEN
    bStartInitDelay := FALSE;
    bInitialized := TRUE;
END_IF

IF bInitialized THEN
    mRun();

        CASE stPneumaticAxisStruct.ePneumaticAxisMode OF

        E_PneumaticMode.eSingleSolenoidControl:
        mSingleSolenoid();

        E_PneumaticMode.eNoPSSPermit:
        mNoPSSPermit();

        E_PneumaticMode.eNoPSSPermitError:
        mNoPSSPermitError();

        E_PneumaticMode.eCylinderRetractInterlocked:
        mRetractedInterlocked();

        E_PneumaticMode.eCylinderExtendInterlocked:
        mExtendedInterlocked();

        E_PneumaticMode.eCylinderRetractInterlockedError:
        mRetractedInterlockedError();

        E_PneumaticMode.eCylinderExtendInterlockedError:
        mExtendedInterlockedError();

        E_PneumaticMode.eLowAirPressure:
        mLowAirPressure();

        E_PneumaticMode.eHighAirPressure:
        mHighAirPressure();

        E_PneumaticMode.eError:
        mSingleSolenoidError();

        E_PneumaticMode.eReset:
        mReset();

        END_CASE
END_IF




















]]></ST>
    </Implementation>
    <Method Name="FB_init" Id="{af7214fb-0537-4a7d-a506-7af30838a02e}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
    bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
    bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bStartInitDelay := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckEndSwitchBwdStatus" Id="{06cf6d5a-16e0-438c-85b6-51ad0c4cc91d}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchBwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn AND NOT bStateChange AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckEndSwitchFwdStatus" Id="{df07c6b6-6902-4500-8747-be2fd3560637}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckEndSwitchFwdStatus

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn AND bStateChange AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForAirPressureError" Id="{f9b14adb-ed69-49af-a993-e6e5d49fd78d}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForAirPressureError : BOOL
VAR
    bAirPressureoutOfRangeError : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbTimerAirPressureErrorLow(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);
fbTimerAirPressureErrorHigh(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);
fbTimerAirPressureNoErrorLow(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);
fbTimerAirPressureNoErrorHigh(IN :=,PT:=INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nAllowTimePressureOutOfRange)*1000, Q=>,ET=>);

//Check if the air pressure value is too low for longer than defined time
IF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled < stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue  THEN
    fbTimerAirPressureErrorLow.IN := TRUE;
    IF fbTimerAirPressureErrorLow.Q THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        bAirPressureoutOfRangeError := TRUE;
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorLow;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eLowAirPressure;
    END_IF


//Check if the air pressure value is too high for longer than defined time
ELSIF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled > stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue  THEN
    fbTimerAirPressureErrorHigh.IN := TRUE;
    IF fbTimerAirPressureErrorHigh.Q THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        bAirPressureoutOfRangeError := TRUE;
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eAirPressureErrorHigh;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eHighAirPressure;
    END_IF


//If the air pressure value is in range, no errors
ELSIF (stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled >= stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue
     AND stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled <= stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue) THEN
    fbTimerAirPressureErrorLow.IN := FALSE;
    fbTimerAirPressureErrorHigh.IN := FALSE;
    bAirPressureoutOfRangeError := FALSE;
END_IF




]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckForMovingError" Id="{38f0c607-b572-456d-8f26-90f3b9594647}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckForMovingError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF the command to extract is given, but the cylinder hasn't moved from the bEndSwitchBwd
IF fbTimerExtend.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingExtract;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//If the command to extract has timed out
IF fbTimerExtend.Q
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eExtractTimedOut;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//IF the command to retract has been given, but the cylinder hasn't moved from bEndSwitchFwd
IF fbTimerRetract.Q AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNotMovingRetract;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF

//If the command to retract has timed out
IF fbTimerRetract.Q
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
   AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eRetractTimedOut;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfInterlockSignal" Id="{3759dc88-e87e-4376-86a5-1bdfbc4158fe}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfInterlockSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPneumaticAxisStruct.stPneumaticAxisConfig.bPSSPneumaticAxisShutter THEN
    stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock := FALSE;
    ELSIF stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'WARNING: INTERLOCK ON, CAN NOT MOVE';
        IF stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted OR stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting THEN
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eCylinderRetractInterlocked;
        END_IF
        IF stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended OR stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending THEN
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eCylinderExtendInterlocked;
        END_IF
END_IF






]]></ST>
      </Implementation>
    </Method>
    <Method Name="mCheckStatusOfPermitSignal" Id="{5d308b37-3dc0-48eb-9350-16f4ad213248}">
      <Declaration><![CDATA[METHOD PUBLIC mCheckStatusOfPermitSignal

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT stPneumaticAxisStruct.stPneumaticAxisConfig.bPSSPneumaticAxisShutter THEN
    stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit := FALSE;
ELSIF NOT stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eNoPSSPermit;
    ELSIF stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;

END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="mExtendedInterlocked" Id="{51cc7600-2ccc-454d-ab69-1386ac754d66}">
      <Declaration><![CDATA[METHOD mExtendedInterlocked


]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := TRUE;
stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
IF NOT stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
END_IF
IF (stPneumaticAxisStruct.stPneumaticAxisControl.bRetract OR stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual) OR bInterlockedExtended THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eExtendInterlocked;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eCylinderExtendInterlockedError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mExtendedInterlockedError" Id="{c0b4e652-3937-42fe-a869-ee6da9ba93ff}">
      <Declaration><![CDATA[METHOD mExtendedInterlockedError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := TRUE;
bInterlockedExtended := TRUE;
stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AXIS INTERLOCKED';
stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;
IF NOT stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    bInterlockedExtended := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="mHighAirPressure" Id="{a41851e4-8444-48e2-8f12-5249a689e7bc}">
      <Declaration><![CDATA[METHOD mHighAirPressure : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO HIGH';
stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;
stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;

IF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled <= stPneumaticAxisStruct.stPneumaticAxisConfig.fHighLimitPressureValue THEN
    fbTimerAirPressureNoErrorHigh.IN := TRUE;
    IF fbTimerAirPressureNoErrorHigh.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    fbTimerAirPressureErrorHigh.IN := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mLowAirPressure" Id="{c0310bb5-42a6-4cfb-b918-7f4740f67c8e}">
      <Declaration><![CDATA[METHOD mLowAirPressure : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AIR PRESSURE TOO LOW';
stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;
stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;

IF stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled >= stPneumaticAxisStruct.stPneumaticAxisConfig.fLowLimitPressureValue THEN
    fbTimerAirPressureNoErrorLow.IN := TRUE;
    IF fbTimerAirPressureNoErrorLow.Q THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    fbTimerAirPressureErrorLow.IN := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNoPSSPermit" Id="{992f1dea-d5e2-43e5-8693-024ad7503be1}">
      <Declaration><![CDATA[METHOD mNoPSSPermit

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'WARNING: NO PERMIT SIGNAL.';
IF (stPneumaticAxisStruct.stPneumaticAxisControl.bExtend OR stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual OR stPneumaticAxisStruct.stPneumaticAxisControl.bRetract OR stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual) OR bNoPSSPermitError THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoPSSPermit;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eNoPSSPermitError;
END_IF
IF stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
        bStateChange := FALSE;
        bStartExtendPLC := FALSE;
        bStartExtendManual := FALSE;
        bStartRetractManual := FALSE;
        bStartRetractPLC := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;

END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNoPSSPermitError" Id="{4bd71f8e-be7a-40c7-9cce-4b92b8835477}">
      <Declaration><![CDATA[METHOD mNoPSSPermitError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[bNoPSSPermitError := TRUE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO PERMIT SIGNAL.';

IF stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit THEN
        bNoPSSPermitError := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
        bStateChange := FALSE;
        bStartExtendPLC := FALSE;
        bStartExtendManual := FALSE;
        bStartRetractManual := FALSE;
        bStartRetractPLC := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
        stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
        stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
        stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;

END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReset" Id="{4721b129-abfa-4113-85bb-a13eb59dedea}">
      <Declaration><![CDATA[METHOD PUBLIC mReset

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Reset all the error messages
//Set the operating mode to Single Solenoid Control
fbTrigRisingEdgePermit(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bReset);
IF stPneumaticAxisStruct.stPneumaticAxisControl.bReset THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisControl.bReset := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRetractedInterlocked" Id="{119414ab-e2e9-44e0-b866-f00dc58d7c9f}">
      <Declaration><![CDATA[METHOD mRetractedInterlocked

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
IF NOT stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
END_IF
IF (stPneumaticAxisStruct.stPneumaticAxisControl.bExtend OR stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual) OR bInterlockedRetracted THEN
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eRetractInterlocked;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eCylinderRetractInterlockedError;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRetractedInterlockedError" Id="{f0f9b367-fd49-420b-9b3d-ab1f518c85fd}">
      <Declaration><![CDATA[METHOD mRetractedInterlockedError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bInterlockedRetracted := TRUE;
stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: AXIS INTERLOCKED';
stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;
IF NOT stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock THEN
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;
    bInterlockedRetracted:= FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'NO_ERRORS_READY_TO_START';
    stPneumaticAxisStruct.ePneumaticAxisErrors := E_PneumaticAxisErrors.eNoError;
    stPneumaticAxisStruct.ePneumaticAxisMode := E_PneumaticMode.eSingleSolenoidControl;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRun" Id="{4ff666c5-8aa4-4eaa-803d-5700cbef55c2}">
      <Declaration><![CDATA[METHOD PUBLIC mRun
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the current status of the end position switches, and permit and intelock signals
mSetInputStatuses();

//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
mSetAllowedTravelTime();

//Get the value of the air pressure in mb
stPneumaticAxisStruct.stPneumaticAxisInputs.fPressureValueScaled := mScaledPressureValue(nRawValue :=  stPneumaticAxisStruct.stPneumaticAxisInputs.nAirPressureValueRaw, fRawHigh := 30518, fRawLow :=0, fScaledHigh := 10, fScaledLow := 0 );

//Check if air pressure is in range
mCheckForAirPressureError();

//Reset Error
mReset();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="mScaledPressureValue" Id="{cb34ab57-a376-4317-a285-420d3612f714}">
      <Declaration><![CDATA[METHOD PUBLIC mScaledPressureValue : REAL
VAR_INPUT
    nRawValue: INT; //Raw value from the Terminal
    fRawHigh: REAL; //Highest value for the Raw value
    fRawLow: REAL; //Lowest value for the Raw value
    fScaledHigh: REAL; //Highest value for the Scaled value
    fScaledLow: REAL; //Lowest value for the Scaled value
END_VAR
VAR
    rGradient: REAL; //Internal variable to calculate gradient of the slope
    rOffset: REAL; //Internal variable to calculate the offset value
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rGradient:= (fScaledHigh - fScaledLow)/(fRawHigh - fRawLow);
rOffset:= fScaledHigh - rGradient * fRawHigh;
mScaledPressureValue:= rGradient * nRawValue + rOffset;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetAllowedTravelTime" Id="{1503d621-dee7-42a9-91aa-f87392c1d737}">
      <Declaration><![CDATA[METHOD PUBLIC mSetAllowedTravelTime

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Enter allowed times for extraction and retraction of pneumatic cylinder in seconds
fbTimerExtend.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToExtend)*1000;
fbTimerRetract.PT := INT_TO_TIME( stPneumaticAxisStruct.stPneumaticAxisConfig.nTimeToRetract)*1000;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSetInputStatuses" Id="{7e8f02a9-eec6-4e57-afc7-756f5956c71a}">
      <Declaration><![CDATA[METHOD PUBLIC mSetInputStatuses
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Set the inputs of limit switches to bExtracted and bRetracted states of the pneumatic cylinders
//Check if cylinder is moving: extending or retracting
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchBwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended := stPneumaticAxisStruct.stPneumaticAxisInputs.bEndSwitchFwd;
stPneumaticAxisStruct.stPneumaticAxisStatus.bSolenoidActive := stPneumaticAxisStruct.stPneumaticAxisInputs.bSolenoidActive;
stPneumaticAxisStruct.stPneumaticAxisStatus.bPSSPermitOK := stPneumaticAxisStruct.stPneumaticAxisInputs.bPSSPermit;
stPneumaticAxisStruct.stPneumaticAxisStatus.bInterlocked := stPneumaticAxisStruct.stPneumaticAxisControl.bInterlock;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoid" Id="{8261ebf9-e0cc-4c7d-9850-4c5e547b1764}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoid

]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Check if Ithe PSS signal for shutter is ON
mCheckStatusOfPermitSignal();

//Check if Interlock signal is ON
mCheckStatusOfInterlockSignal();

//Starting the timing of extraction movement
fbTimerExtend(IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending);
stPneumaticAxisStruct.stPneumaticAxisStatus.nTimeElapsedExtend := TIME_TO_INT(fbTimerExtend.ET);

fbTrigExtend(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bExtend);
IF fbTrigExtend.Q THEN
   bStartExtendPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigExtendManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bOpenManual);
IF fbTrigExtendManual.Q THEN
   bStartExtendManual := TRUE;
END_IF

//Starting the extraction movement
IF (bStartExtendPLC OR bStartExtendManual) THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := TRUE;
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
       AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := TRUE;
    END_IF
    //If the command to retract is given while the cylinder is extracting
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
          AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        IF (bStartRetractPLC OR bStartRetractManual) THEN
            stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
            stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
            stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
            bStartExtendPLC := FALSE;
            bStartExtendManual := FALSE;
        END_IF
    END_IF
END_IF

// Extraction of the cylinder finished, reset timer
IF (bStartExtendPLC OR bStartExtendManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended THEN
    bStateChange := TRUE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
    bStartExtendPLC := FALSE;
    bStartExtendManual := FALSE;
END_IF

//Check if LimitSwitchBwd signal is ON
mCheckEndSwitchFwdStatus();


//Starting the retraction movement and retraction timing
fbTimerRetract (IN := stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting);
stPneumaticAxisStruct.stPneumaticAxisStatus.nTimeElapsedRetract := TIME_TO_INT(fbTimerRetract.ET);

fbTrigRetract(clk:=stPneumaticAxisStruct.stPneumaticAxisControl.bRetract);
IF fbTrigRetract.Q THEN
   bStartRetractPLC := TRUE;
END_IF

//If the manual momentary push button is used for control of the pneumatic cylinder
fbTrigRetractManual(clk:=stPneumaticAxisStruct.stPneumaticAxisInputs.bCloseManual);
IF fbTrigRetractManual.Q THEN
   bStartRetractManual := TRUE;
END_IF

IF (bStartRetractPLC OR bStartRetractManual) THEN
    stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
    IF NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bExtended
       AND NOT stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
        stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := TRUE;
    END_IF
END_IF

// Retraction of the cylinder finished, reset timer
IF  (bStartRetractPLC OR bStartRetractManual) AND stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracted THEN
    bStateChange := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;
    stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
    bStartRetractPLC := FALSE;
    bStartRetractManual := FALSE;
END_IF
//Check if LimitSwitchFwd signal is ON
mCheckEndSwitchBwdStatus();


mCheckForMovingError();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mSingleSolenoidError" Id="{9bc66883-6ee1-41c7-aebe-403858ab95d4}">
      <Declaration><![CDATA[METHOD PUBLIC mSingleSolenoidError

]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE  stPneumaticAxisStruct.ePneumaticAxisErrors OF

    E_PneumaticAxisErrors.eNoError:
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := FALSE;

    E_PneumaticAxisErrors.eExtractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eRetractTimedOut:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: COMMAND TIMED OUT';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingExtract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNotMovingRetract:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: CYLINDER NOT MOVING';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchBwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM END SWITCH BWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

    E_PneumaticAxisErrors.eNoSignalFromEndSwitchFwd:
    stPneumaticAxisStruct.stPneumaticAxisStatus.sStatus := 'ERROR: NO SIGNAL FROM LIMIT SWITCH FWD';
    stPneumaticAxisStruct.stPneumaticAxisStatus.bError := TRUE;

END_CASE

stPneumaticAxisStruct.stPneumaticAxisControl.bExtend := FALSE;
stPneumaticAxisStruct.stPneumaticAxisControl.bRetract := FALSE;
stPneumaticAxisStruct.stPneumaticAxisOutputs.bValveOn := FALSE;
bStateChange := FALSE;
bStartExtendPLC := FALSE;
bStartExtendManual := FALSE;
bStartRetractManual := FALSE;
bStartRetractPLC := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bExtending := FALSE;
stPneumaticAxisStruct.stPneumaticAxisStatus.bRetracting := FALSE;


]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>